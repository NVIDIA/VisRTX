// Copyright (c) 2019-2024 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
// SPDX-License-Identifier: BSD-3-Clause
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
// 1. Redistributions of source code must retain the above copyright notice,
// this list of conditions and the following disclaimer.
//
// 2. Redistributions in binary form must reproduce the above copyright notice,
// this list of conditions and the following disclaimer in the documentation
// and/or other materials provided with the distribution.
//
// 3. Neither the name of the copyright holder nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
// This file was generated by generate_device_frontend.py
// Don't make changes to this directly

#pragma once
#include "VisGLParameter.h"
namespace visgl{
class ParameterPack {
public:
   virtual bool set(const char *paramname, ANARIDataType type, const void *mem) = 0;
   virtual void unset(const char *paramname) = 0;
   virtual ParameterBase& operator[](size_t idx) = 0;
   virtual ParameterBase& operator[](const char *paramname) = 0;
   virtual const char** paramNames() const = 0;
   virtual size_t paramCount() const = 0;
};
class Device : public ParameterPack {
public:
   ANARIDevice device;
   ANARIObject object;
   static const int type = ANARI_DEVICE;
   static constexpr const char *subtype = nullptr;
   static const uint32_t id = 0;
   Parameter<ANARI_STRING> name;
   Parameter<ANARI_STATUS_CALLBACK> statusCallback;
   Parameter<ANARI_VOID_POINTER> statusCallbackUserData;
   Parameter<ANARI_STRING> glAPI;
   Parameter<ANARI_BOOL> glDebug;
   Parameter<ANARI_VOID_POINTER> EGLDisplay;
   Parameter<ANARI_VOID_POINTER> EGlContext;
   Parameter<ANARI_STRING> geometryPrecision;

   Device(ANARIDevice d, ANARIObject o);
   bool set(const char *paramname, ANARIDataType type, const void *mem) override;
   void unset(const char *paramname) override;
   ParameterBase& operator[](size_t idx) override;
   ParameterBase& operator[](const char *paramname) override;
   const char** paramNames() const override;
   size_t paramCount() const override;
};
class Array1D : public ParameterPack {
public:
   ANARIDevice device;
   ANARIObject object;
   static const int type = ANARI_ARRAY1D;
   static constexpr const char *subtype = nullptr;
   static const uint32_t id = 1;
   Parameter<ANARI_STRING> name;

   Array1D(ANARIDevice d, ANARIObject o);
   bool set(const char *paramname, ANARIDataType type, const void *mem) override;
   void unset(const char *paramname) override;
   ParameterBase& operator[](size_t idx) override;
   ParameterBase& operator[](const char *paramname) override;
   const char** paramNames() const override;
   size_t paramCount() const override;
};
class Array2D : public ParameterPack {
public:
   ANARIDevice device;
   ANARIObject object;
   static const int type = ANARI_ARRAY2D;
   static constexpr const char *subtype = nullptr;
   static const uint32_t id = 2;
   Parameter<ANARI_STRING> name;

   Array2D(ANARIDevice d, ANARIObject o);
   bool set(const char *paramname, ANARIDataType type, const void *mem) override;
   void unset(const char *paramname) override;
   ParameterBase& operator[](size_t idx) override;
   ParameterBase& operator[](const char *paramname) override;
   const char** paramNames() const override;
   size_t paramCount() const override;
};
class Array3D : public ParameterPack {
public:
   ANARIDevice device;
   ANARIObject object;
   static const int type = ANARI_ARRAY3D;
   static constexpr const char *subtype = nullptr;
   static const uint32_t id = 3;
   Parameter<ANARI_STRING> name;

   Array3D(ANARIDevice d, ANARIObject o);
   bool set(const char *paramname, ANARIDataType type, const void *mem) override;
   void unset(const char *paramname) override;
   ParameterBase& operator[](size_t idx) override;
   ParameterBase& operator[](const char *paramname) override;
   const char** paramNames() const override;
   size_t paramCount() const override;
};
class Frame : public ParameterPack {
public:
   ANARIDevice device;
   ANARIObject object;
   static const int type = ANARI_FRAME;
   static constexpr const char *subtype = nullptr;
   static const uint32_t id = 4;
   Parameter<ANARI_STRING> name;
   Parameter<ANARI_WORLD> world;
   Parameter<ANARI_RENDERER> renderer;
   Parameter<ANARI_CAMERA> camera;
   Parameter<ANARI_UINT32_VEC2> size;
   Parameter<ANARI_DATA_TYPE> channel_color;
   Parameter<ANARI_DATA_TYPE> channel_depth;

   Frame(ANARIDevice d, ANARIObject o);
   bool set(const char *paramname, ANARIDataType type, const void *mem) override;
   void unset(const char *paramname) override;
   ParameterBase& operator[](size_t idx) override;
   ParameterBase& operator[](const char *paramname) override;
   const char** paramNames() const override;
   size_t paramCount() const override;
};
class Group : public ParameterPack {
public:
   ANARIDevice device;
   ANARIObject object;
   static const int type = ANARI_GROUP;
   static constexpr const char *subtype = nullptr;
   static const uint32_t id = 5;
   Parameter<ANARI_STRING> name;
   Parameter<ANARI_ARRAY1D> surface;
   Parameter<ANARI_ARRAY1D> volume;
   Parameter<ANARI_ARRAY1D> light;

   Group(ANARIDevice d, ANARIObject o);
   bool set(const char *paramname, ANARIDataType type, const void *mem) override;
   void unset(const char *paramname) override;
   ParameterBase& operator[](size_t idx) override;
   ParameterBase& operator[](const char *paramname) override;
   const char** paramNames() const override;
   size_t paramCount() const override;
};
class World : public ParameterPack {
public:
   ANARIDevice device;
   ANARIObject object;
   static const int type = ANARI_WORLD;
   static constexpr const char *subtype = nullptr;
   static const uint32_t id = 6;
   Parameter<ANARI_STRING> name;
   Parameter<ANARI_ARRAY1D> instance;
   Parameter<ANARI_ARRAY1D> surface;
   Parameter<ANARI_ARRAY1D> volume;
   Parameter<ANARI_ARRAY1D> light;

   World(ANARIDevice d, ANARIObject o);
   bool set(const char *paramname, ANARIDataType type, const void *mem) override;
   void unset(const char *paramname) override;
   ParameterBase& operator[](size_t idx) override;
   ParameterBase& operator[](const char *paramname) override;
   const char** paramNames() const override;
   size_t paramCount() const override;
};
class RendererDefault : public ParameterPack {
public:
   ANARIDevice device;
   ANARIObject object;
   static const int type = ANARI_RENDERER;
   static constexpr const char *subtype = "default";
   static const uint32_t id = 7;
   Parameter<ANARI_STRING> name;
   Parameter<ANARI_FLOAT32_VEC3> ambientColor;
   Parameter<ANARI_FLOAT32> ambientRadiance;
   Parameter<ANARI_FLOAT32_VEC4> background;
   Parameter<ANARI_INT32> shadowMapSize;
   Parameter<ANARI_STRING> occlusionMode;

   RendererDefault(ANARIDevice d, ANARIObject o);
   bool set(const char *paramname, ANARIDataType type, const void *mem) override;
   void unset(const char *paramname) override;
   ParameterBase& operator[](size_t idx) override;
   ParameterBase& operator[](const char *paramname) override;
   const char** paramNames() const override;
   size_t paramCount() const override;
};
class Surface : public ParameterPack {
public:
   ANARIDevice device;
   ANARIObject object;
   static const int type = ANARI_SURFACE;
   static constexpr const char *subtype = nullptr;
   static const uint32_t id = 8;
   Parameter<ANARI_STRING> name;
   Parameter<ANARI_GEOMETRY> geometry;
   Parameter<ANARI_MATERIAL> material;

   Surface(ANARIDevice d, ANARIObject o);
   bool set(const char *paramname, ANARIDataType type, const void *mem) override;
   void unset(const char *paramname) override;
   ParameterBase& operator[](size_t idx) override;
   ParameterBase& operator[](const char *paramname) override;
   const char** paramNames() const override;
   size_t paramCount() const override;
};
class InstanceTransform : public ParameterPack {
public:
   ANARIDevice device;
   ANARIObject object;
   static const int type = ANARI_INSTANCE;
   static constexpr const char *subtype = "transform";
   static const uint32_t id = 9;
   Parameter<ANARI_STRING> name;
   Parameter<ANARI_FLOAT32_MAT4> transform;
   Parameter<ANARI_GROUP> group;

   InstanceTransform(ANARIDevice d, ANARIObject o);
   bool set(const char *paramname, ANARIDataType type, const void *mem) override;
   void unset(const char *paramname) override;
   ParameterBase& operator[](size_t idx) override;
   ParameterBase& operator[](const char *paramname) override;
   const char** paramNames() const override;
   size_t paramCount() const override;
};
class VolumeTransferFunction1D : public ParameterPack {
public:
   ANARIDevice device;
   ANARIObject object;
   static const int type = ANARI_VOLUME;
   static constexpr const char *subtype = "transferFunction1D";
   static const uint32_t id = 10;
   Parameter<ANARI_STRING> name;
   Parameter<ANARI_SPATIAL_FIELD> value;
   Parameter<ANARI_FLOAT32_BOX1, ANARI_FLOAT64_BOX1> valueRange;
   Parameter<ANARI_FLOAT32_VEC4, ANARI_FLOAT32_VEC3, ANARI_ARRAY1D> color;
   Parameter<ANARI_FLOAT32, ANARI_ARRAY1D> opacity;
   Parameter<ANARI_FLOAT32> unitDistance;

   VolumeTransferFunction1D(ANARIDevice d, ANARIObject o);
   bool set(const char *paramname, ANARIDataType type, const void *mem) override;
   void unset(const char *paramname) override;
   ParameterBase& operator[](size_t idx) override;
   ParameterBase& operator[](const char *paramname) override;
   const char** paramNames() const override;
   size_t paramCount() const override;
};
class CameraOrthographic : public ParameterPack {
public:
   ANARIDevice device;
   ANARIObject object;
   static const int type = ANARI_CAMERA;
   static constexpr const char *subtype = "orthographic";
   static const uint32_t id = 11;
   Parameter<ANARI_STRING> name;
   Parameter<ANARI_FLOAT32_VEC3> position;
   Parameter<ANARI_FLOAT32_VEC3> direction;
   Parameter<ANARI_FLOAT32_VEC3> up;
   Parameter<ANARI_FLOAT32_BOX2> imageRegion;
   Parameter<ANARI_FLOAT32> aspect;
   Parameter<ANARI_FLOAT32> height;
   Parameter<ANARI_FLOAT32> near;
   Parameter<ANARI_FLOAT32> far;

   CameraOrthographic(ANARIDevice d, ANARIObject o);
   bool set(const char *paramname, ANARIDataType type, const void *mem) override;
   void unset(const char *paramname) override;
   ParameterBase& operator[](size_t idx) override;
   ParameterBase& operator[](const char *paramname) override;
   const char** paramNames() const override;
   size_t paramCount() const override;
};
class CameraPerspective : public ParameterPack {
public:
   ANARIDevice device;
   ANARIObject object;
   static const int type = ANARI_CAMERA;
   static constexpr const char *subtype = "perspective";
   static const uint32_t id = 12;
   Parameter<ANARI_STRING> name;
   Parameter<ANARI_FLOAT32_VEC3> position;
   Parameter<ANARI_FLOAT32_VEC3> direction;
   Parameter<ANARI_FLOAT32_VEC3> up;
   Parameter<ANARI_FLOAT32_BOX2> imageRegion;
   Parameter<ANARI_FLOAT32> fovy;
   Parameter<ANARI_FLOAT32> aspect;
   Parameter<ANARI_FLOAT32> near;
   Parameter<ANARI_FLOAT32> far;

   CameraPerspective(ANARIDevice d, ANARIObject o);
   bool set(const char *paramname, ANARIDataType type, const void *mem) override;
   void unset(const char *paramname) override;
   ParameterBase& operator[](size_t idx) override;
   ParameterBase& operator[](const char *paramname) override;
   const char** paramNames() const override;
   size_t paramCount() const override;
};
class GeometryCylinder : public ParameterPack {
public:
   ANARIDevice device;
   ANARIObject object;
   static const int type = ANARI_GEOMETRY;
   static constexpr const char *subtype = "cylinder";
   static const uint32_t id = 13;
   Parameter<ANARI_STRING> name;
   Parameter<ANARI_FLOAT32_VEC4> color;
   Parameter<ANARI_FLOAT32_VEC4> attribute0;
   Parameter<ANARI_FLOAT32_VEC4> attribute1;
   Parameter<ANARI_FLOAT32_VEC4> attribute2;
   Parameter<ANARI_FLOAT32_VEC4> attribute3;
   Parameter<ANARI_ARRAY1D> primitive_color;
   Parameter<ANARI_ARRAY1D> primitive_attribute0;
   Parameter<ANARI_ARRAY1D> primitive_attribute1;
   Parameter<ANARI_ARRAY1D> primitive_attribute2;
   Parameter<ANARI_ARRAY1D> primitive_attribute3;
   Parameter<ANARI_ARRAY1D> primitive_id;
   Parameter<ANARI_ARRAY1D> vertex_position;
   Parameter<ANARI_ARRAY1D> vertex_cap;
   Parameter<ANARI_ARRAY1D> vertex_color;
   Parameter<ANARI_ARRAY1D> vertex_attribute0;
   Parameter<ANARI_ARRAY1D> vertex_attribute1;
   Parameter<ANARI_ARRAY1D> vertex_attribute2;
   Parameter<ANARI_ARRAY1D> vertex_attribute3;
   Parameter<ANARI_ARRAY1D> primitive_index;
   Parameter<ANARI_ARRAY1D> primitive_radius;
   Parameter<ANARI_FLOAT32> radius;
   Parameter<ANARI_STRING> caps;
   Parameter<ANARI_STRING> geometryPrecision;

   GeometryCylinder(ANARIDevice d, ANARIObject o);
   bool set(const char *paramname, ANARIDataType type, const void *mem) override;
   void unset(const char *paramname) override;
   ParameterBase& operator[](size_t idx) override;
   ParameterBase& operator[](const char *paramname) override;
   const char** paramNames() const override;
   size_t paramCount() const override;
};
class GeometrySphere : public ParameterPack {
public:
   ANARIDevice device;
   ANARIObject object;
   static const int type = ANARI_GEOMETRY;
   static constexpr const char *subtype = "sphere";
   static const uint32_t id = 14;
   Parameter<ANARI_STRING> name;
   Parameter<ANARI_FLOAT32_VEC4> color;
   Parameter<ANARI_FLOAT32_VEC4> attribute0;
   Parameter<ANARI_FLOAT32_VEC4> attribute1;
   Parameter<ANARI_FLOAT32_VEC4> attribute2;
   Parameter<ANARI_FLOAT32_VEC4> attribute3;
   Parameter<ANARI_ARRAY1D> primitive_color;
   Parameter<ANARI_ARRAY1D> primitive_attribute0;
   Parameter<ANARI_ARRAY1D> primitive_attribute1;
   Parameter<ANARI_ARRAY1D> primitive_attribute2;
   Parameter<ANARI_ARRAY1D> primitive_attribute3;
   Parameter<ANARI_ARRAY1D> primitive_id;
   Parameter<ANARI_ARRAY1D> vertex_position;
   Parameter<ANARI_ARRAY1D> vertex_radius;
   Parameter<ANARI_ARRAY1D> vertex_color;
   Parameter<ANARI_ARRAY1D> vertex_attribute0;
   Parameter<ANARI_ARRAY1D> vertex_attribute1;
   Parameter<ANARI_ARRAY1D> vertex_attribute2;
   Parameter<ANARI_ARRAY1D> vertex_attribute3;
   Parameter<ANARI_ARRAY1D> primitive_index;
   Parameter<ANARI_FLOAT32> radius;
   Parameter<ANARI_STRING> geometryPrecision;

   GeometrySphere(ANARIDevice d, ANARIObject o);
   bool set(const char *paramname, ANARIDataType type, const void *mem) override;
   void unset(const char *paramname) override;
   ParameterBase& operator[](size_t idx) override;
   ParameterBase& operator[](const char *paramname) override;
   const char** paramNames() const override;
   size_t paramCount() const override;
};
class GeometryTriangle : public ParameterPack {
public:
   ANARIDevice device;
   ANARIObject object;
   static const int type = ANARI_GEOMETRY;
   static constexpr const char *subtype = "triangle";
   static const uint32_t id = 15;
   Parameter<ANARI_STRING> name;
   Parameter<ANARI_FLOAT32_VEC4> color;
   Parameter<ANARI_FLOAT32_VEC4> attribute0;
   Parameter<ANARI_FLOAT32_VEC4> attribute1;
   Parameter<ANARI_FLOAT32_VEC4> attribute2;
   Parameter<ANARI_FLOAT32_VEC4> attribute3;
   Parameter<ANARI_ARRAY1D> primitive_color;
   Parameter<ANARI_ARRAY1D> primitive_attribute0;
   Parameter<ANARI_ARRAY1D> primitive_attribute1;
   Parameter<ANARI_ARRAY1D> primitive_attribute2;
   Parameter<ANARI_ARRAY1D> primitive_attribute3;
   Parameter<ANARI_ARRAY1D> primitive_id;
   Parameter<ANARI_ARRAY1D> vertex_position;
   Parameter<ANARI_ARRAY1D> vertex_normal;
   Parameter<ANARI_ARRAY1D> vertex_tangent;
   Parameter<ANARI_ARRAY1D> vertex_color;
   Parameter<ANARI_ARRAY1D> vertex_attribute0;
   Parameter<ANARI_ARRAY1D> vertex_attribute1;
   Parameter<ANARI_ARRAY1D> vertex_attribute2;
   Parameter<ANARI_ARRAY1D> vertex_attribute3;
   Parameter<ANARI_ARRAY1D> primitive_index;

   GeometryTriangle(ANARIDevice d, ANARIObject o);
   bool set(const char *paramname, ANARIDataType type, const void *mem) override;
   void unset(const char *paramname) override;
   ParameterBase& operator[](size_t idx) override;
   ParameterBase& operator[](const char *paramname) override;
   const char** paramNames() const override;
   size_t paramCount() const override;
};
class LightDirectional : public ParameterPack {
public:
   ANARIDevice device;
   ANARIObject object;
   static const int type = ANARI_LIGHT;
   static constexpr const char *subtype = "directional";
   static const uint32_t id = 16;
   Parameter<ANARI_STRING> name;
   Parameter<ANARI_FLOAT32_VEC3> color;
   Parameter<ANARI_FLOAT32> irradiance;
   Parameter<ANARI_FLOAT32_VEC3> direction;

   LightDirectional(ANARIDevice d, ANARIObject o);
   bool set(const char *paramname, ANARIDataType type, const void *mem) override;
   void unset(const char *paramname) override;
   ParameterBase& operator[](size_t idx) override;
   ParameterBase& operator[](const char *paramname) override;
   const char** paramNames() const override;
   size_t paramCount() const override;
};
class LightPoint : public ParameterPack {
public:
   ANARIDevice device;
   ANARIObject object;
   static const int type = ANARI_LIGHT;
   static constexpr const char *subtype = "point";
   static const uint32_t id = 17;
   Parameter<ANARI_STRING> name;
   Parameter<ANARI_FLOAT32_VEC3> color;
   Parameter<ANARI_FLOAT32_VEC3> position;
   Parameter<ANARI_FLOAT32> intensity;
   Parameter<ANARI_FLOAT32> power;

   LightPoint(ANARIDevice d, ANARIObject o);
   bool set(const char *paramname, ANARIDataType type, const void *mem) override;
   void unset(const char *paramname) override;
   ParameterBase& operator[](size_t idx) override;
   ParameterBase& operator[](const char *paramname) override;
   const char** paramNames() const override;
   size_t paramCount() const override;
};
class LightSpot : public ParameterPack {
public:
   ANARIDevice device;
   ANARIObject object;
   static const int type = ANARI_LIGHT;
   static constexpr const char *subtype = "spot";
   static const uint32_t id = 18;
   Parameter<ANARI_STRING> name;
   Parameter<ANARI_FLOAT32_VEC3> color;
   Parameter<ANARI_FLOAT32_VEC3> position;
   Parameter<ANARI_FLOAT32_VEC3> direction;
   Parameter<ANARI_FLOAT32> openingAngle;
   Parameter<ANARI_FLOAT32> falloffAngle;
   Parameter<ANARI_FLOAT32> intensity;
   Parameter<ANARI_FLOAT32> power;

   LightSpot(ANARIDevice d, ANARIObject o);
   bool set(const char *paramname, ANARIDataType type, const void *mem) override;
   void unset(const char *paramname) override;
   ParameterBase& operator[](size_t idx) override;
   ParameterBase& operator[](const char *paramname) override;
   const char** paramNames() const override;
   size_t paramCount() const override;
};
class MaterialMatte : public ParameterPack {
public:
   ANARIDevice device;
   ANARIObject object;
   static const int type = ANARI_MATERIAL;
   static constexpr const char *subtype = "matte";
   static const uint32_t id = 19;
   Parameter<ANARI_STRING> name;
   Parameter<ANARI_FLOAT32_VEC3, ANARI_SAMPLER, ANARI_STRING> color;
   Parameter<ANARI_FLOAT32, ANARI_SAMPLER, ANARI_STRING> opacity;
   Parameter<ANARI_STRING> alphaMode;
   Parameter<ANARI_FLOAT32> alphaCutoff;

   MaterialMatte(ANARIDevice d, ANARIObject o);
   bool set(const char *paramname, ANARIDataType type, const void *mem) override;
   void unset(const char *paramname) override;
   ParameterBase& operator[](size_t idx) override;
   ParameterBase& operator[](const char *paramname) override;
   const char** paramNames() const override;
   size_t paramCount() const override;
};
class MaterialPhysicallyBased : public ParameterPack {
public:
   ANARIDevice device;
   ANARIObject object;
   static const int type = ANARI_MATERIAL;
   static constexpr const char *subtype = "physicallyBased";
   static const uint32_t id = 20;
   Parameter<ANARI_STRING> name;
   Parameter<ANARI_FLOAT32_VEC3, ANARI_SAMPLER, ANARI_STRING> baseColor;
   Parameter<ANARI_FLOAT32, ANARI_SAMPLER, ANARI_STRING> opacity;
   Parameter<ANARI_FLOAT32, ANARI_SAMPLER, ANARI_STRING> metallic;
   Parameter<ANARI_FLOAT32, ANARI_SAMPLER, ANARI_STRING> roughness;
   Parameter<ANARI_SAMPLER> normal;
   Parameter<ANARI_FLOAT32_VEC3, ANARI_SAMPLER, ANARI_STRING> emissive;
   Parameter<ANARI_SAMPLER> occlusion;
   Parameter<ANARI_STRING> alphaMode;
   Parameter<ANARI_FLOAT32> alphaCutoff;
   Parameter<ANARI_FLOAT32, ANARI_SAMPLER, ANARI_STRING> specular;
   Parameter<ANARI_FLOAT32_VEC3, ANARI_SAMPLER, ANARI_STRING> specularColor;
   Parameter<ANARI_FLOAT32, ANARI_SAMPLER, ANARI_STRING> clearcoat;
   Parameter<ANARI_FLOAT32, ANARI_SAMPLER, ANARI_STRING> clearcoatRoughness;
   Parameter<ANARI_SAMPLER> clearcoatNormal;
   Parameter<ANARI_FLOAT32, ANARI_SAMPLER, ANARI_STRING> transmission;
   Parameter<ANARI_FLOAT32, ANARI_SAMPLER, ANARI_STRING> ior;
   Parameter<ANARI_FLOAT32, ANARI_SAMPLER, ANARI_STRING> thickness;
   Parameter<ANARI_FLOAT32> attenuationDistance;
   Parameter<ANARI_FLOAT32_VEC3> attenuationColor;
   Parameter<ANARI_FLOAT32_VEC3, ANARI_SAMPLER, ANARI_STRING> sheenColor;
   Parameter<ANARI_FLOAT32, ANARI_SAMPLER, ANARI_STRING> sheenRoughness;
   Parameter<ANARI_FLOAT32, ANARI_SAMPLER, ANARI_STRING> iridescence;
   Parameter<ANARI_FLOAT32> iridescenceIor;
   Parameter<ANARI_FLOAT32, ANARI_SAMPLER, ANARI_STRING> iridescenceThickness;

   MaterialPhysicallyBased(ANARIDevice d, ANARIObject o);
   bool set(const char *paramname, ANARIDataType type, const void *mem) override;
   void unset(const char *paramname) override;
   ParameterBase& operator[](size_t idx) override;
   ParameterBase& operator[](const char *paramname) override;
   const char** paramNames() const override;
   size_t paramCount() const override;
};
class SamplerImage1D : public ParameterPack {
public:
   ANARIDevice device;
   ANARIObject object;
   static const int type = ANARI_SAMPLER;
   static constexpr const char *subtype = "image1D";
   static const uint32_t id = 21;
   Parameter<ANARI_STRING> name;
   Parameter<ANARI_ARRAY1D> image;
   Parameter<ANARI_STRING> inAttribute;
   Parameter<ANARI_STRING> filter;
   Parameter<ANARI_STRING> wrapMode1;
   Parameter<ANARI_FLOAT32_MAT4> inTransform;
   Parameter<ANARI_FLOAT32_VEC4> inOffset;
   Parameter<ANARI_FLOAT32_MAT4> outTransform;
   Parameter<ANARI_FLOAT32_VEC4> outOffset;

   SamplerImage1D(ANARIDevice d, ANARIObject o);
   bool set(const char *paramname, ANARIDataType type, const void *mem) override;
   void unset(const char *paramname) override;
   ParameterBase& operator[](size_t idx) override;
   ParameterBase& operator[](const char *paramname) override;
   const char** paramNames() const override;
   size_t paramCount() const override;
};
class SamplerImage2D : public ParameterPack {
public:
   ANARIDevice device;
   ANARIObject object;
   static const int type = ANARI_SAMPLER;
   static constexpr const char *subtype = "image2D";
   static const uint32_t id = 22;
   Parameter<ANARI_STRING> name;
   Parameter<ANARI_ARRAY2D> image;
   Parameter<ANARI_STRING> inAttribute;
   Parameter<ANARI_STRING> filter;
   Parameter<ANARI_STRING> wrapMode1;
   Parameter<ANARI_STRING> wrapMode2;
   Parameter<ANARI_FLOAT32_MAT4> inTransform;
   Parameter<ANARI_FLOAT32_VEC4> inOffset;
   Parameter<ANARI_FLOAT32_MAT4> outTransform;
   Parameter<ANARI_FLOAT32_VEC4> outOffset;

   SamplerImage2D(ANARIDevice d, ANARIObject o);
   bool set(const char *paramname, ANARIDataType type, const void *mem) override;
   void unset(const char *paramname) override;
   ParameterBase& operator[](size_t idx) override;
   ParameterBase& operator[](const char *paramname) override;
   const char** paramNames() const override;
   size_t paramCount() const override;
};
class SamplerImage3D : public ParameterPack {
public:
   ANARIDevice device;
   ANARIObject object;
   static const int type = ANARI_SAMPLER;
   static constexpr const char *subtype = "image3D";
   static const uint32_t id = 23;
   Parameter<ANARI_STRING> name;
   Parameter<ANARI_ARRAY3D> image;
   Parameter<ANARI_STRING> inAttribute;
   Parameter<ANARI_STRING> filter;
   Parameter<ANARI_STRING> wrapMode1;
   Parameter<ANARI_STRING> wrapMode2;
   Parameter<ANARI_STRING> wrapMode3;
   Parameter<ANARI_FLOAT32_MAT4> inTransform;
   Parameter<ANARI_FLOAT32_VEC4> inOffset;
   Parameter<ANARI_FLOAT32_MAT4> outTransform;
   Parameter<ANARI_FLOAT32_VEC4> outOffset;

   SamplerImage3D(ANARIDevice d, ANARIObject o);
   bool set(const char *paramname, ANARIDataType type, const void *mem) override;
   void unset(const char *paramname) override;
   ParameterBase& operator[](size_t idx) override;
   ParameterBase& operator[](const char *paramname) override;
   const char** paramNames() const override;
   size_t paramCount() const override;
};
class SamplerPrimitive : public ParameterPack {
public:
   ANARIDevice device;
   ANARIObject object;
   static const int type = ANARI_SAMPLER;
   static constexpr const char *subtype = "primitive";
   static const uint32_t id = 24;
   Parameter<ANARI_STRING> name;
   Parameter<ANARI_ARRAY1D> array;
   Parameter<ANARI_UINT64> inOffset;

   SamplerPrimitive(ANARIDevice d, ANARIObject o);
   bool set(const char *paramname, ANARIDataType type, const void *mem) override;
   void unset(const char *paramname) override;
   ParameterBase& operator[](size_t idx) override;
   ParameterBase& operator[](const char *paramname) override;
   const char** paramNames() const override;
   size_t paramCount() const override;
};
class SamplerTransform : public ParameterPack {
public:
   ANARIDevice device;
   ANARIObject object;
   static const int type = ANARI_SAMPLER;
   static constexpr const char *subtype = "transform";
   static const uint32_t id = 25;
   Parameter<ANARI_STRING> name;
   Parameter<ANARI_STRING> inAttribute;
   Parameter<ANARI_FLOAT32_MAT4> outTransform;
   Parameter<ANARI_FLOAT32_VEC4> outOffset;

   SamplerTransform(ANARIDevice d, ANARIObject o);
   bool set(const char *paramname, ANARIDataType type, const void *mem) override;
   void unset(const char *paramname) override;
   ParameterBase& operator[](size_t idx) override;
   ParameterBase& operator[](const char *paramname) override;
   const char** paramNames() const override;
   size_t paramCount() const override;
};
class Spatial_FieldStructuredRegular : public ParameterPack {
public:
   ANARIDevice device;
   ANARIObject object;
   static const int type = ANARI_SPATIAL_FIELD;
   static constexpr const char *subtype = "structuredRegular";
   static const uint32_t id = 26;
   Parameter<ANARI_STRING> name;
   Parameter<ANARI_ARRAY3D> data;
   Parameter<ANARI_FLOAT32_VEC3> origin;
   Parameter<ANARI_FLOAT32_VEC3> spacing;
   Parameter<ANARI_STRING> filter;

   Spatial_FieldStructuredRegular(ANARIDevice d, ANARIObject o);
   bool set(const char *paramname, ANARIDataType type, const void *mem) override;
   void unset(const char *paramname) override;
   ParameterBase& operator[](size_t idx) override;
   ParameterBase& operator[](const char *paramname) override;
   const char** paramNames() const override;
   size_t paramCount() const override;
};
class SamplerCompressedImage2D : public ParameterPack {
public:
   ANARIDevice device;
   ANARIObject object;
   static const int type = ANARI_SAMPLER;
   static constexpr const char *subtype = "compressedImage2D";
   static const uint32_t id = 27;
   Parameter<ANARI_STRING> name;
   Parameter<ANARI_ARRAY1D> image;
   Parameter<ANARI_STRING> format;
   Parameter<ANARI_UINT64_VEC2> size;
   Parameter<ANARI_STRING> inAttribute;
   Parameter<ANARI_STRING> filter;
   Parameter<ANARI_STRING> wrapMode1;
   Parameter<ANARI_STRING> wrapMode2;
   Parameter<ANARI_FLOAT32_MAT4> inTransform;
   Parameter<ANARI_FLOAT32_VEC4> inOffset;
   Parameter<ANARI_FLOAT32_MAT4> outTransform;
   Parameter<ANARI_FLOAT32_VEC4> outOffset;

   SamplerCompressedImage2D(ANARIDevice d, ANARIObject o);
   bool set(const char *paramname, ANARIDataType type, const void *mem) override;
   void unset(const char *paramname) override;
   ParameterBase& operator[](size_t idx) override;
   ParameterBase& operator[](const char *paramname) override;
   const char** paramNames() const override;
   size_t paramCount() const override;
};
class GeometryCone : public ParameterPack {
public:
   ANARIDevice device;
   ANARIObject object;
   static const int type = ANARI_GEOMETRY;
   static constexpr const char *subtype = "cone";
   static const uint32_t id = 28;
   Parameter<ANARI_STRING> geometryPrecision;

   GeometryCone(ANARIDevice d, ANARIObject o);
   bool set(const char *paramname, ANARIDataType type, const void *mem) override;
   void unset(const char *paramname) override;
   ParameterBase& operator[](size_t idx) override;
   ParameterBase& operator[](const char *paramname) override;
   const char** paramNames() const override;
   size_t paramCount() const override;
};
} //namespace visgl
