// Copyright (c) 2019-2023 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
// SPDX-License-Identifier: BSD-3-Clause
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
// 1. Redistributions of source code must retain the above copyright notice,
// this list of conditions and the following disclaimer.
//
// 2. Redistributions in binary form must reproduce the above copyright notice,
// this list of conditions and the following disclaimer in the documentation
// and/or other materials provided with the distribution.
//
// 3. Neither the name of the copyright holder nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
// This file was generated by generate_device_frontend.py
// Don't make changes to this directly

#include <stdint.h>
#include "VisGLObjects.h"
namespace visgl{
static int param_hash(const char *str) {
   static const uint32_t table[] = {0x48470033u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x756c0065u,0x626100d6u,0x706100f7u,0x6a6101c6u,0x6e6d01e5u,0x706101edu,0x7365023eu,0x666502bcu,0x736d02c2u,0x0u,0x0u,0x6a610410u,0x66610422u,0x70610435u,0x7663044fu,0x736f0521u,0x0u,0x70610578u,0x7668059bu,0x736806b0u,0x717006d9u,0x706106dbu,0x736f0751u,0x6d4c0034u,0x45440055u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x4443005du,0x6a690056u,0x74730057u,0x71700058u,0x6d6c0059u,0x6261005au,0x7a79005bu,0x100005cu,0x80000000u,0x706f005eu,0x6f6e005fu,0x75740060u,0x66650061u,0x79780062u,0x75740063u,0x1000064u,0x80000001u,0x7170006eu,0x63620086u,0x0u,0x0u,0x666500a8u,0x0u,0x737200b5u,0x717000b9u,0x757400beu,0x6968006fu,0x62610070u,0x4e430071u,0x7675007cu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x706f0082u,0x7574007du,0x706f007eu,0x6766007fu,0x67660080u,0x1000081u,0x80000002u,0x65640083u,0x66650084u,0x1000085u,0x80000003u,0x6a690087u,0x66650088u,0x6f6e0089u,0x7574008au,0x5343008bu,0x706f009bu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x626100a0u,0x6d6c009cu,0x706f009du,0x7372009eu,0x100009fu,0x80000004u,0x656400a1u,0x6a6900a2u,0x626100a3u,0x6f6e00a4u,0x646300a5u,0x666500a6u,0x10000a7u,0x80000005u,0x737200a9u,0x757400aau,0x767500abu,0x737200acu,0x666500adu,0x535200aeu,0x626100afu,0x656400b0u,0x6a6900b1u,0x767500b2u,0x747300b3u,0x10000b4u,0x80000006u,0x626100b6u,0x7a7900b7u,0x10000b8u,0x80000007u,0x666500bau,0x646300bbu,0x757400bcu,0x10000bdu,0x80000008u,0x666500bfu,0x6f6e00c0u,0x767500c1u,0x626100c2u,0x757400c3u,0x6a6900c4u,0x706f00c5u,0x6f6e00c6u,0x454300c7u,0x706f00c9u,0x6a6900ceu,0x6d6c00cau,0x706f00cbu,0x737200ccu,0x10000cdu,0x80000009u,0x747300cfu,0x757400d0u,0x626100d1u,0x6f6e00d2u,0x646300d3u,0x666500d4u,0x10000d5u,0x8000000au,0x746300d7u,0x6c6b00e8u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x666500f0u,0x686700e9u,0x737200eau,0x706f00ebu,0x767500ecu,0x6f6e00edu,0x656400eeu,0x10000efu,0x8000000bu,0x444300f1u,0x706f00f2u,0x6d6c00f3u,0x706f00f4u,0x737200f5u,0x10000f6u,0x8000000cu,0x716d0106u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x62610110u,0x0u,0x0u,0x0u,0x66650122u,0x0u,0x0u,0x6d6c018bu,0x6665010au,0x0u,0x0u,0x7473010eu,0x7372010bu,0x6261010cu,0x100010du,0x8000000du,0x100010fu,0x8000000eu,0x6f6e0111u,0x6f6e0112u,0x66650113u,0x6d6c0114u,0x2f2e0115u,0x65630116u,0x706f0118u,0x6665011du,0x6d6c0119u,0x706f011au,0x7372011bu,0x100011cu,0x8000000fu,0x7170011eu,0x7574011fu,0x69680120u,0x1000121u,0x80000010u,0x62610123u,0x73720124u,0x64630125u,0x706f0126u,0x62610127u,0x75740128u,0x53000129u,0x80000011u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x706f017cu,0x0u,0x0u,0x0u,0x706f0182u,0x7372017du,0x6e6d017eu,0x6261017fu,0x6d6c0180u,0x1000181u,0x80000012u,0x76750183u,0x68670184u,0x69680185u,0x6f6e0186u,0x66650187u,0x74730188u,0x74730189u,0x100018au,0x80000013u,0x706f018cu,0x7372018du,0x2f00018eu,0x80000014u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x717001bdu,0x706f01beu,0x747301bfu,0x6a6901c0u,0x757401c1u,0x6a6901c2u,0x706f01c3u,0x6f6e01c4u,0x10001c5u,0x80000015u,0x757401cfu,0x0u,0x0u,0x0u,0x6f6e01d2u,0x0u,0x0u,0x0u,0x737201ddu,0x626101d0u,0x10001d1u,0x80000016u,0x747301d3u,0x6a6901d4u,0x757401d5u,0x7a7901d6u,0x545301d7u,0x646301d8u,0x626101d9u,0x6d6c01dau,0x666501dbu,0x10001dcu,0x80000017u,0x666501deu,0x646301dfu,0x757401e0u,0x6a6901e1u,0x706f01e2u,0x6f6e01e3u,0x10001e4u,0x80000018u,0x6a6901e6u,0x747301e7u,0x747301e8u,0x6a6901e9u,0x777601eau,0x666501ebu,0x10001ecu,0x80000019u,0x736c01fcu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6d65020eu,0x0u,0x0u,0x0u,0x0u,0x0u,0x7763021du,0x6d6c0203u,0x0u,0x0u,0x0u,0x0u,0x0u,0x100020du,0x706f0204u,0x67660205u,0x67660206u,0x42410207u,0x6f6e0208u,0x68670209u,0x6d6c020au,0x6665020bu,0x100020cu,0x8000001au,0x8000001bu,0x6d6c0216u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x75740219u,0x65640217u,0x1000218u,0x8000001cu,0x6665021au,0x7372021bu,0x100021cu,0x8000001du,0x76750231u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x7a79023cu,0x74730232u,0x45440233u,0x6a690234u,0x74730235u,0x75740236u,0x62610237u,0x6f6e0238u,0x64630239u,0x6665023au,0x100023bu,0x8000001eu,0x100023du,0x8000001fu,0x706f024cu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x454102acu,0x0u,0x0u,0x0u,0x0u,0x0u,0x706f02b8u,0x6e6d024du,0x6665024eu,0x7574024fu,0x73720250u,0x7a790251u,0x51000252u,0x80000020u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x737202a3u,0x666502a4u,0x646302a5u,0x6a6902a6u,0x747302a7u,0x6a6902a8u,0x706f02a9u,0x6f6e02aau,0x10002abu,0x80000021u,0x515002b0u,0x0u,0x0u,0x666502b3u,0x4a4902b1u,0x10002b2u,0x80000022u,0x636202b4u,0x767502b5u,0x686702b6u,0x10002b7u,0x80000023u,0x767502b9u,0x717002bau,0x10002bbu,0x80000024u,0x6a6902bdu,0x686702beu,0x696802bfu,0x757402c0u,0x10002c1u,0x80000025u,0x626102c8u,0x75410324u,0x73720393u,0x0u,0x0u,0x73690395u,0x686702c9u,0x666502cau,0x530002cbu,0x80000026u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6665031eu,0x6867031fu,0x6a690320u,0x706f0321u,0x6f6e0322u,0x1000323u,0x80000027u,0x75740358u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x67660361u,0x0u,0x0u,0x0u,0x0u,0x73720367u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x75740370u,0x66650376u,0x75740359u,0x7372035au,0x6a69035bu,0x6362035cu,0x7675035du,0x7574035eu,0x6665035fu,0x1000360u,0x80000028u,0x67660362u,0x74730363u,0x66650364u,0x75740365u,0x1000366u,0x80000029u,0x62610368u,0x6f6e0369u,0x7473036au,0x6766036bu,0x706f036cu,0x7372036du,0x6e6d036eu,0x100036fu,0x8000002au,0x62610371u,0x6f6e0372u,0x64630373u,0x66650374u,0x1000375u,0x8000002bu,0x736e0377u,0x7473037cu,0x0u,0x0u,0x0u,0x71700381u,0x6a69037du,0x7574037eu,0x7a79037fu,0x1000380u,0x8000002cu,0x76750382u,0x71700383u,0x6a690384u,0x6d6c0385u,0x6d6c0386u,0x62610387u,0x73720388u,0x7a790389u,0x4544038au,0x6a69038bu,0x7473038cu,0x7574038du,0x6261038eu,0x6f6e038fu,0x64630390u,0x66650391u,0x1000392u,0x8000002du,0x1000394u,0x8000002eu,0x6564039fu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x62610408u,0x666503a0u,0x747303a1u,0x646303a2u,0x666503a3u,0x6f6e03a4u,0x646303a5u,0x666503a6u,0x550003a7u,0x8000002fu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x706f03fcu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x696803ffu,0x737203fdu,0x10003feu,0x80000030u,0x6a690400u,0x64630401u,0x6c6b0402u,0x6f6e0403u,0x66650404u,0x74730405u,0x74730406u,0x1000407u,0x80000031u,0x65640409u,0x6a69040au,0x6261040bu,0x6f6e040cu,0x6463040du,0x6665040eu,0x100040fu,0x80000032u,0x7a790419u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6867041eu,0x706f041au,0x7675041bu,0x7574041cu,0x100041du,0x80000033u,0x6968041fu,0x75740420u,0x1000421u,0x80000034u,0x75740427u,0x0u,0x0u,0x0u,0x7574042eu,0x66650428u,0x73720429u,0x6a69042au,0x6261042bu,0x6d6c042cu,0x100042du,0x80000035u,0x6261042fu,0x6d6c0430u,0x6d6c0431u,0x6a690432u,0x64630433u,0x1000434u,0x80000036u,0x6e6d0444u,0x0u,0x0u,0x0u,0x62610447u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x7372044au,0x66650445u,0x1000446u,0x80000037u,0x73720448u,0x1000449u,0x80000038u,0x6e6d044bu,0x6261044cu,0x6d6c044du,0x100044eu,0x80000039u,0x64630462u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x666104bbu,0x0u,0x6a690506u,0x0u,0x0u,0x7574050bu,0x6d6c0463u,0x76750464u,0x74730465u,0x6a690466u,0x706f0467u,0x6f6e0468u,0x4e000469u,0x8000003au,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x706f04b7u,0x656404b8u,0x666504b9u,0x10004bau,0x8000003bu,0x646304c0u,0x0u,0x0u,0x0u,0x6f6e04fcu,0x6a6904c1u,0x757404c2u,0x7a7904c3u,0x2f0004c4u,0x8000003cu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x717004f3u,0x706f04f4u,0x747304f5u,0x6a6904f6u,0x757404f7u,0x6a6904f8u,0x706f04f9u,0x6f6e04fau,0x10004fbu,0x8000003du,0x6a6904fdu,0x6f6e04feu,0x686704ffu,0x42410500u,0x6f6e0501u,0x68670502u,0x6d6c0503u,0x66650504u,0x1000505u,0x8000003eu,0x68670507u,0x6a690508u,0x6f6e0509u,0x100050au,0x8000003fu,0x554f050cu,0x67660512u,0x0u,0x0u,0x0u,0x0u,0x73720518u,0x67660513u,0x74730514u,0x66650515u,0x75740516u,0x1000517u,0x80000040u,0x62610519u,0x6f6e051au,0x7473051bu,0x6766051cu,0x706f051du,0x7372051eu,0x6e6d051fu,0x1000520u,0x80000041u,0x78730525u,0x0u,0x0u,0x6a690533u,0x6a69052au,0x0u,0x0u,0x0u,0x66650530u,0x7574052bu,0x6a69052cu,0x706f052du,0x6f6e052eu,0x100052fu,0x80000042u,0x73720531u,0x1000532u,0x80000043u,0x6e6d0534u,0x6a690535u,0x75740536u,0x6a690537u,0x77760538u,0x66650539u,0x2f2e053au,0x7361053bu,0x7574054du,0x0u,0x706f055du,0x0u,0x0u,0x0u,0x0u,0x0u,0x6f640562u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x62610572u,0x7574054eu,0x7372054fu,0x6a690550u,0x63620551u,0x76750552u,0x75740553u,0x66650554u,0x34300555u,0x1000559u,0x100055au,0x100055bu,0x100055cu,0x80000044u,0x80000045u,0x80000046u,0x80000047u,0x6d6c055eu,0x706f055fu,0x73720560u,0x1000561u,0x80000048u,0x100056du,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6564056eu,0x80000049u,0x6665056fu,0x79780570u,0x1000571u,0x8000004au,0x65640573u,0x6a690574u,0x76750575u,0x74730576u,0x1000577u,0x8000004bu,0x65640587u,0x0u,0x0u,0x0u,0x6f6e058cu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x76750593u,0x6a690588u,0x76750589u,0x7473058au,0x100058bu,0x8000004cu,0x6564058du,0x6665058eu,0x7372058fu,0x66650590u,0x73720591u,0x1000592u,0x8000004du,0x68670594u,0x69680595u,0x6f6e0596u,0x66650597u,0x74730598u,0x74730599u,0x100059au,0x8000004eu,0x666105a9u,0x7b7a05d9u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x666105dcu,0x0u,0x0u,0x0u,0x66610634u,0x737206aau,0x656405aeu,0x0u,0x0u,0x0u,0x666505b9u,0x706f05afu,0x787705b0u,0x4e4d05b1u,0x626105b2u,0x717005b3u,0x545305b4u,0x6a6905b5u,0x7b7a05b6u,0x666505b7u,0x10005b8u,0x8000004fu,0x6f6e05bau,0x534305bbu,0x706f05cbu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x706f05d0u,0x6d6c05ccu,0x706f05cdu,0x737205ceu,0x10005cfu,0x80000050u,0x767505d1u,0x686705d2u,0x696805d3u,0x6f6e05d4u,0x666505d5u,0x747305d6u,0x747305d7u,0x10005d8u,0x80000051u,0x666505dau,0x10005dbu,0x80000052u,0x646305e1u,0x0u,0x0u,0x0u,0x646305e6u,0x6a6905e2u,0x6f6e05e3u,0x686705e4u,0x10005e5u,0x80000053u,0x767505e7u,0x6d6c05e8u,0x626105e9u,0x737205eau,0x440005ebu,0x80000054u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x706f062fu,0x6d6c0630u,0x706f0631u,0x73720632u,0x1000633u,0x80000055u,0x75740639u,0x0u,0x0u,0x0u,0x737206a2u,0x7675063au,0x7473063bu,0x4443063cu,0x6261063du,0x6d6c063eu,0x6d6c063fu,0x63620640u,0x62610641u,0x64630642u,0x6c6b0643u,0x56000644u,0x80000056u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x7473069au,0x6665069bu,0x7372069cu,0x4544069du,0x6261069eu,0x7574069fu,0x626106a0u,0x10006a1u,0x80000057u,0x666506a3u,0x706f06a4u,0x4e4d06a5u,0x706f06a6u,0x656406a7u,0x666506a8u,0x10006a9u,0x80000058u,0x676606abu,0x626106acu,0x646306adu,0x666506aeu,0x10006afu,0x80000059u,0x6a6906bbu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x626106c3u,0x646306bcu,0x6c6b06bdu,0x6f6e06beu,0x666506bfu,0x747306c0u,0x747306c1u,0x10006c2u,0x8000005au,0x6f6e06c4u,0x747306c5u,0x6e6606c6u,0x706f06ceu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6a6906d2u,0x737206cfu,0x6e6d06d0u,0x10006d1u,0x8000005bu,0x747306d3u,0x747306d4u,0x6a6906d5u,0x706f06d6u,0x6f6e06d7u,0x10006d8u,0x8000005cu,0x10006dau,0x8000005du,0x6d6c06eau,0x0u,0x0u,0x0u,0x737206f3u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6d6c074cu,0x767506ebu,0x666506ecu,0x535206edu,0x626106eeu,0x6f6e06efu,0x686706f0u,0x666506f1u,0x10006f2u,0x8000005eu,0x757406f4u,0x666506f5u,0x797806f6u,0x2f2e06f7u,0x756106f8u,0x7574070cu,0x0u,0x7061071cu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x706f0731u,0x0u,0x706f0737u,0x0u,0x6261073fu,0x0u,0x62610745u,0x7574070du,0x7372070eu,0x6a69070fu,0x63620710u,0x76750711u,0x75740712u,0x66650713u,0x34300714u,0x1000718u,0x1000719u,0x100071au,0x100071bu,0x8000005fu,0x80000060u,0x80000061u,0x80000062u,0x7170072bu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6d6c072du,0x100072cu,0x80000063u,0x706f072eu,0x7372072fu,0x1000730u,0x80000064u,0x73720732u,0x6e6d0733u,0x62610734u,0x6d6c0735u,0x1000736u,0x80000065u,0x74730738u,0x6a690739u,0x7574073au,0x6a69073bu,0x706f073cu,0x6f6e073du,0x100073eu,0x80000066u,0x65640740u,0x6a690741u,0x76750742u,0x74730743u,0x1000744u,0x80000067u,0x6f6e0746u,0x68670747u,0x66650748u,0x6f6e0749u,0x7574074au,0x100074bu,0x80000068u,0x7675074du,0x6e6d074eu,0x6665074fu,0x1000750u,0x80000069u,0x73720755u,0x0u,0x0u,0x62610759u,0x6d6c0756u,0x65640757u,0x1000758u,0x8000006au,0x7170075au,0x4e4d075bu,0x706f075cu,0x6564075du,0x6665075eu,0x3431075fu,0x1000762u,0x1000763u,0x1000764u,0x8000006bu,0x8000006cu,0x8000006du};
   uint32_t cur = 0x78450000u;
   for(int i = 0;cur!=0;++i) {
      uint32_t idx = cur&0xFFFFu;
      uint32_t low = (cur>>16u)&0xFFu;
      uint32_t high = (cur>>24u)&0xFFu;
      uint32_t c = (uint32_t)str[i];
      if(c>=low && c<high) {
         cur = table[idx+c-low];
      } else {
         break;
      }
      if(cur&0x80000000u) {
         return cur&0xFFFFu;
      }
      if(str[i]==0) {
         break;
      }
   }
   return -1;
}
Device::Device(ANARIDevice device, ANARIObject o) : device(device), object(o) {
   {
      const char *value = "OpenGL_ES";
      glAPI.set(device, object, ANARI_STRING, value);
   }
   {
      int32_t value[] = {INT32_C(0)};
      glDebug.set(device, object, ANARI_BOOL, value);
   }
   {
      const char *value = "tessellate";
      geometryPrecision.set(device, object, ANARI_STRING, value);
   }
}
bool Device::set(const char *paramname, ANARIDataType type, const void *mem) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: //name
         return name.set(device, object, type, mem);
      case 86: //statusCallback
         return statusCallback.set(device, object, type, mem);
      case 87: //statusCallbackUserData
         return statusCallbackUserData.set(device, object, type, mem);
      case 34: //glAPI
         return glAPI.set(device, object, type, mem);
      case 35: //glDebug
         return glDebug.set(device, object, type, mem);
      case 0: //EGLDisplay
         return EGLDisplay.set(device, object, type, mem);
      case 1: //EGlContext
         return EGlContext.set(device, object, type, mem);
      case 33: //geometryPrecision
         return geometryPrecision.set(device, object, type, mem);
      default: // unknown param
         //unknown parameter
         return false;
   }
}
void Device::unset(const char *paramname) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: //name
         name.unset(device, object);
         return;
      case 86: //statusCallback
         statusCallback.unset(device, object);
         return;
      case 87: //statusCallbackUserData
         statusCallbackUserData.unset(device, object);
         return;
      case 34: //glAPI
         {
            const char *value = "OpenGL_ES";
            glAPI.set(device, object, ANARI_STRING, value);
         }
         return;
      case 35: //glDebug
         {
            int32_t value[] = {INT32_C(0)};
            glDebug.set(device, object, ANARI_BOOL, value);
         }
         return;
      case 0: //EGLDisplay
         EGLDisplay.unset(device, object);
         return;
      case 1: //EGlContext
         EGlContext.unset(device, object);
         return;
      case 33: //geometryPrecision
         {
            const char *value = "tessellate";
            geometryPrecision.set(device, object, ANARI_STRING, value);
         }
         return;
      default: // unknown param
         //unknown parameter
         return;
   }
}
ParameterBase& Device::operator[](size_t idx) {
   static EmptyParameter empty;
   switch(idx) {
      case 0: return name;
      case 1: return statusCallback;
      case 2: return statusCallbackUserData;
      case 3: return glAPI;
      case 4: return glDebug;
      case 5: return EGLDisplay;
      case 6: return EGlContext;
      case 7: return geometryPrecision;
      default: return empty;
   }
}
ParameterBase& Device::operator[](const char *paramname) {
   static EmptyParameter empty;
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: return name;
      case 86: return statusCallback;
      case 87: return statusCallbackUserData;
      case 34: return glAPI;
      case 35: return glDebug;
      case 0: return EGLDisplay;
      case 1: return EGlContext;
      case 33: return geometryPrecision;
      default: return empty;
   }
}
const char ** Device::paramNames() const {
   static const char *paramnames[] = {
      "name",
      "statusCallback",
      "statusCallbackUserData",
      "glAPI",
      "glDebug",
      "EGLDisplay",
      "EGlContext",
      "geometryPrecision",
      nullptr
   };
   return paramnames;
}
size_t Device::paramCount() const {
   return 8;
}

Array1D::Array1D(ANARIDevice device, ANARIObject o) : device(device), object(o) {
}
bool Array1D::set(const char *paramname, ANARIDataType type, const void *mem) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: //name
         return name.set(device, object, type, mem);
      default: // unknown param
         //unknown parameter
         return false;
   }
}
void Array1D::unset(const char *paramname) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: //name
         name.unset(device, object);
         return;
      default: // unknown param
         //unknown parameter
         return;
   }
}
ParameterBase& Array1D::operator[](size_t idx) {
   static EmptyParameter empty;
   switch(idx) {
      case 0: return name;
      default: return empty;
   }
}
ParameterBase& Array1D::operator[](const char *paramname) {
   static EmptyParameter empty;
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: return name;
      default: return empty;
   }
}
const char ** Array1D::paramNames() const {
   static const char *paramnames[] = {
      "name",
      nullptr
   };
   return paramnames;
}
size_t Array1D::paramCount() const {
   return 1;
}

Array2D::Array2D(ANARIDevice device, ANARIObject o) : device(device), object(o) {
}
bool Array2D::set(const char *paramname, ANARIDataType type, const void *mem) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: //name
         return name.set(device, object, type, mem);
      default: // unknown param
         //unknown parameter
         return false;
   }
}
void Array2D::unset(const char *paramname) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: //name
         name.unset(device, object);
         return;
      default: // unknown param
         //unknown parameter
         return;
   }
}
ParameterBase& Array2D::operator[](size_t idx) {
   static EmptyParameter empty;
   switch(idx) {
      case 0: return name;
      default: return empty;
   }
}
ParameterBase& Array2D::operator[](const char *paramname) {
   static EmptyParameter empty;
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: return name;
      default: return empty;
   }
}
const char ** Array2D::paramNames() const {
   static const char *paramnames[] = {
      "name",
      nullptr
   };
   return paramnames;
}
size_t Array2D::paramCount() const {
   return 1;
}

Array3D::Array3D(ANARIDevice device, ANARIObject o) : device(device), object(o) {
}
bool Array3D::set(const char *paramname, ANARIDataType type, const void *mem) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: //name
         return name.set(device, object, type, mem);
      default: // unknown param
         //unknown parameter
         return false;
   }
}
void Array3D::unset(const char *paramname) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: //name
         name.unset(device, object);
         return;
      default: // unknown param
         //unknown parameter
         return;
   }
}
ParameterBase& Array3D::operator[](size_t idx) {
   static EmptyParameter empty;
   switch(idx) {
      case 0: return name;
      default: return empty;
   }
}
ParameterBase& Array3D::operator[](const char *paramname) {
   static EmptyParameter empty;
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: return name;
      default: return empty;
   }
}
const char ** Array3D::paramNames() const {
   static const char *paramnames[] = {
      "name",
      nullptr
   };
   return paramnames;
}
size_t Array3D::paramCount() const {
   return 1;
}

Frame::Frame(ANARIDevice device, ANARIObject o) : device(device), object(o) {
}
bool Frame::set(const char *paramname, ANARIDataType type, const void *mem) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: //name
         return name.set(device, object, type, mem);
      case 106: //world
         return world.set(device, object, type, mem);
      case 77: //renderer
         return renderer.set(device, object, type, mem);
      case 13: //camera
         return camera.set(device, object, type, mem);
      case 82: //size
         return size.set(device, object, type, mem);
      case 15: //channel.color
         return channel_color.set(device, object, type, mem);
      case 16: //channel.depth
         return channel_depth.set(device, object, type, mem);
      default: // unknown param
         //unknown parameter
         return false;
   }
}
void Frame::unset(const char *paramname) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: //name
         name.unset(device, object);
         return;
      case 106: //world
         world.unset(device, object);
         return;
      case 77: //renderer
         renderer.unset(device, object);
         return;
      case 13: //camera
         camera.unset(device, object);
         return;
      case 82: //size
         size.unset(device, object);
         return;
      case 15: //channel.color
         channel_color.unset(device, object);
         return;
      case 16: //channel.depth
         channel_depth.unset(device, object);
         return;
      default: // unknown param
         //unknown parameter
         return;
   }
}
ParameterBase& Frame::operator[](size_t idx) {
   static EmptyParameter empty;
   switch(idx) {
      case 0: return name;
      case 1: return world;
      case 2: return renderer;
      case 3: return camera;
      case 4: return size;
      case 5: return channel_color;
      case 6: return channel_depth;
      default: return empty;
   }
}
ParameterBase& Frame::operator[](const char *paramname) {
   static EmptyParameter empty;
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: return name;
      case 106: return world;
      case 77: return renderer;
      case 13: return camera;
      case 82: return size;
      case 15: return channel_color;
      case 16: return channel_depth;
      default: return empty;
   }
}
const char ** Frame::paramNames() const {
   static const char *paramnames[] = {
      "name",
      "world",
      "renderer",
      "camera",
      "size",
      "channel.color",
      "channel.depth",
      nullptr
   };
   return paramnames;
}
size_t Frame::paramCount() const {
   return 7;
}

Group::Group(ANARIDevice device, ANARIObject o) : device(device), object(o) {
}
bool Group::set(const char *paramname, ANARIDataType type, const void *mem) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: //name
         return name.set(device, object, type, mem);
      case 89: //surface
         return surface.set(device, object, type, mem);
      case 105: //volume
         return volume.set(device, object, type, mem);
      case 52: //light
         return light.set(device, object, type, mem);
      default: // unknown param
         //unknown parameter
         return false;
   }
}
void Group::unset(const char *paramname) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: //name
         name.unset(device, object);
         return;
      case 89: //surface
         surface.unset(device, object);
         return;
      case 105: //volume
         volume.unset(device, object);
         return;
      case 52: //light
         light.unset(device, object);
         return;
      default: // unknown param
         //unknown parameter
         return;
   }
}
ParameterBase& Group::operator[](size_t idx) {
   static EmptyParameter empty;
   switch(idx) {
      case 0: return name;
      case 1: return surface;
      case 2: return volume;
      case 3: return light;
      default: return empty;
   }
}
ParameterBase& Group::operator[](const char *paramname) {
   static EmptyParameter empty;
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: return name;
      case 89: return surface;
      case 105: return volume;
      case 52: return light;
      default: return empty;
   }
}
const char ** Group::paramNames() const {
   static const char *paramnames[] = {
      "name",
      "surface",
      "volume",
      "light",
      nullptr
   };
   return paramnames;
}
size_t Group::paramCount() const {
   return 4;
}

World::World(ANARIDevice device, ANARIObject o) : device(device), object(o) {
}
bool World::set(const char *paramname, ANARIDataType type, const void *mem) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: //name
         return name.set(device, object, type, mem);
      case 43: //instance
         return instance.set(device, object, type, mem);
      case 89: //surface
         return surface.set(device, object, type, mem);
      case 105: //volume
         return volume.set(device, object, type, mem);
      case 52: //light
         return light.set(device, object, type, mem);
      default: // unknown param
         //unknown parameter
         return false;
   }
}
void World::unset(const char *paramname) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: //name
         name.unset(device, object);
         return;
      case 43: //instance
         instance.unset(device, object);
         return;
      case 89: //surface
         surface.unset(device, object);
         return;
      case 105: //volume
         volume.unset(device, object);
         return;
      case 52: //light
         light.unset(device, object);
         return;
      default: // unknown param
         //unknown parameter
         return;
   }
}
ParameterBase& World::operator[](size_t idx) {
   static EmptyParameter empty;
   switch(idx) {
      case 0: return name;
      case 1: return instance;
      case 2: return surface;
      case 3: return volume;
      case 4: return light;
      default: return empty;
   }
}
ParameterBase& World::operator[](const char *paramname) {
   static EmptyParameter empty;
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: return name;
      case 43: return instance;
      case 89: return surface;
      case 105: return volume;
      case 52: return light;
      default: return empty;
   }
}
const char ** World::paramNames() const {
   static const char *paramnames[] = {
      "name",
      "instance",
      "surface",
      "volume",
      "light",
      nullptr
   };
   return paramnames;
}
size_t World::paramCount() const {
   return 5;
}

RendererDefault::RendererDefault(ANARIDevice device, ANARIObject o) : device(device), object(o) {
   {
      float value[] = {1.000000f, 1.000000f, 1.000000f};
      ambientColor.set(device, object, ANARI_FLOAT32_VEC3, value);
   }
   {
      float value[] = {0.000000f};
      ambientRadiance.set(device, object, ANARI_FLOAT32, value);
   }
   {
      float value[] = {0.000000f, 0.000000f, 0.000000f, 1.000000f};
      background.set(device, object, ANARI_FLOAT32_VEC4, value);
   }
   {
      int32_t value[] = {INT32_C(0)};
      shadowMapSize.set(device, object, ANARI_INT32, value);
   }
   {
      const char *value = "none";
      occlusionMode.set(device, object, ANARI_STRING, value);
   }
}
bool RendererDefault::set(const char *paramname, ANARIDataType type, const void *mem) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: //name
         return name.set(device, object, type, mem);
      case 4: //ambientColor
         return ambientColor.set(device, object, type, mem);
      case 5: //ambientRadiance
         return ambientRadiance.set(device, object, type, mem);
      case 11: //background
         return background.set(device, object, type, mem);
      case 79: //shadowMapSize
         return shadowMapSize.set(device, object, type, mem);
      case 59: //occlusionMode
         return occlusionMode.set(device, object, type, mem);
      default: // unknown param
         //unknown parameter
         return false;
   }
}
void RendererDefault::unset(const char *paramname) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: //name
         name.unset(device, object);
         return;
      case 4: //ambientColor
         {
            float value[] = {1.000000f, 1.000000f, 1.000000f};
            ambientColor.set(device, object, ANARI_FLOAT32_VEC3, value);
         }
         return;
      case 5: //ambientRadiance
         {
            float value[] = {0.000000f};
            ambientRadiance.set(device, object, ANARI_FLOAT32, value);
         }
         return;
      case 11: //background
         {
            float value[] = {0.000000f, 0.000000f, 0.000000f, 1.000000f};
            background.set(device, object, ANARI_FLOAT32_VEC4, value);
         }
         return;
      case 79: //shadowMapSize
         {
            int32_t value[] = {INT32_C(0)};
            shadowMapSize.set(device, object, ANARI_INT32, value);
         }
         return;
      case 59: //occlusionMode
         {
            const char *value = "none";
            occlusionMode.set(device, object, ANARI_STRING, value);
         }
         return;
      default: // unknown param
         //unknown parameter
         return;
   }
}
ParameterBase& RendererDefault::operator[](size_t idx) {
   static EmptyParameter empty;
   switch(idx) {
      case 0: return name;
      case 1: return ambientColor;
      case 2: return ambientRadiance;
      case 3: return background;
      case 4: return shadowMapSize;
      case 5: return occlusionMode;
      default: return empty;
   }
}
ParameterBase& RendererDefault::operator[](const char *paramname) {
   static EmptyParameter empty;
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: return name;
      case 4: return ambientColor;
      case 5: return ambientRadiance;
      case 11: return background;
      case 79: return shadowMapSize;
      case 59: return occlusionMode;
      default: return empty;
   }
}
const char ** RendererDefault::paramNames() const {
   static const char *paramnames[] = {
      "name",
      "ambientColor",
      "ambientRadiance",
      "background",
      "shadowMapSize",
      "occlusionMode",
      nullptr
   };
   return paramnames;
}
size_t RendererDefault::paramCount() const {
   return 6;
}

Surface::Surface(ANARIDevice device, ANARIObject o) : device(device), object(o) {
}
bool Surface::set(const char *paramname, ANARIDataType type, const void *mem) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: //name
         return name.set(device, object, type, mem);
      case 32: //geometry
         return geometry.set(device, object, type, mem);
      case 53: //material
         return material.set(device, object, type, mem);
      default: // unknown param
         //unknown parameter
         return false;
   }
}
void Surface::unset(const char *paramname) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: //name
         name.unset(device, object);
         return;
      case 32: //geometry
         geometry.unset(device, object);
         return;
      case 53: //material
         material.unset(device, object);
         return;
      default: // unknown param
         //unknown parameter
         return;
   }
}
ParameterBase& Surface::operator[](size_t idx) {
   static EmptyParameter empty;
   switch(idx) {
      case 0: return name;
      case 1: return geometry;
      case 2: return material;
      default: return empty;
   }
}
ParameterBase& Surface::operator[](const char *paramname) {
   static EmptyParameter empty;
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: return name;
      case 32: return geometry;
      case 53: return material;
      default: return empty;
   }
}
const char ** Surface::paramNames() const {
   static const char *paramnames[] = {
      "name",
      "geometry",
      "material",
      nullptr
   };
   return paramnames;
}
size_t Surface::paramCount() const {
   return 3;
}

InstanceTransform::InstanceTransform(ANARIDevice device, ANARIObject o) : device(device), object(o) {
   {
      float value[] = {1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f};
      transform.set(device, object, ANARI_FLOAT32_MAT4, value);
   }
}
bool InstanceTransform::set(const char *paramname, ANARIDataType type, const void *mem) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: //name
         return name.set(device, object, type, mem);
      case 91: //transform
         return transform.set(device, object, type, mem);
      case 36: //group
         return group.set(device, object, type, mem);
      default: // unknown param
         //unknown parameter
         return false;
   }
}
void InstanceTransform::unset(const char *paramname) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: //name
         name.unset(device, object);
         return;
      case 91: //transform
         {
            float value[] = {1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f};
            transform.set(device, object, ANARI_FLOAT32_MAT4, value);
         }
         return;
      case 36: //group
         group.unset(device, object);
         return;
      default: // unknown param
         //unknown parameter
         return;
   }
}
ParameterBase& InstanceTransform::operator[](size_t idx) {
   static EmptyParameter empty;
   switch(idx) {
      case 0: return name;
      case 1: return transform;
      case 2: return group;
      default: return empty;
   }
}
ParameterBase& InstanceTransform::operator[](const char *paramname) {
   static EmptyParameter empty;
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: return name;
      case 91: return transform;
      case 36: return group;
      default: return empty;
   }
}
const char ** InstanceTransform::paramNames() const {
   static const char *paramnames[] = {
      "name",
      "transform",
      "group",
      nullptr
   };
   return paramnames;
}
size_t InstanceTransform::paramCount() const {
   return 3;
}

CameraOmnidirectional::CameraOmnidirectional(ANARIDevice device, ANARIObject o) : device(device), object(o) {
   {
      float value[] = {0.000000f, 0.000000f, 0.000000f};
      position.set(device, object, ANARI_FLOAT32_VEC3, value);
   }
   {
      float value[] = {0.000000f, 0.000000f, -1.000000f};
      direction.set(device, object, ANARI_FLOAT32_VEC3, value);
   }
   {
      float value[] = {0.000000f, 1.000000f, 0.000000f};
      up.set(device, object, ANARI_FLOAT32_VEC3, value);
   }
   {
      float value[] = {1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f};
      transform.set(device, object, ANARI_FLOAT32_MAT4, value);
   }
   {
      float value[] = {0.000000f, 0.000000f, 1.000000f, 1.000000f};
      imageRegion.set(device, object, ANARI_FLOAT32_BOX2, value);
   }
   {
      float value[] = {0.000000f};
      apertureRadius.set(device, object, ANARI_FLOAT32, value);
   }
   {
      float value[] = {1.000000f};
      focusDistance.set(device, object, ANARI_FLOAT32, value);
   }
   {
      const char *value = "none";
      stereoMode.set(device, object, ANARI_STRING, value);
   }
   {
      float value[] = {0.063500f};
      interpupillaryDistance.set(device, object, ANARI_FLOAT32, value);
   }
   {
      const char *value = "equirectangular";
      layout.set(device, object, ANARI_STRING, value);
   }
}
bool CameraOmnidirectional::set(const char *paramname, ANARIDataType type, const void *mem) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: //name
         return name.set(device, object, type, mem);
      case 66: //position
         return position.set(device, object, type, mem);
      case 24: //direction
         return direction.set(device, object, type, mem);
      case 93: //up
         return up.set(device, object, type, mem);
      case 91: //transform
         return transform.set(device, object, type, mem);
      case 39: //imageRegion
         return imageRegion.set(device, object, type, mem);
      case 6: //apertureRadius
         return apertureRadius.set(device, object, type, mem);
      case 30: //focusDistance
         return focusDistance.set(device, object, type, mem);
      case 88: //stereoMode
         return stereoMode.set(device, object, type, mem);
      case 45: //interpupillaryDistance
         return interpupillaryDistance.set(device, object, type, mem);
      case 51: //layout
         return layout.set(device, object, type, mem);
      default: // unknown param
         //unknown parameter
         return false;
   }
}
void CameraOmnidirectional::unset(const char *paramname) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: //name
         name.unset(device, object);
         return;
      case 66: //position
         {
            float value[] = {0.000000f, 0.000000f, 0.000000f};
            position.set(device, object, ANARI_FLOAT32_VEC3, value);
         }
         return;
      case 24: //direction
         {
            float value[] = {0.000000f, 0.000000f, -1.000000f};
            direction.set(device, object, ANARI_FLOAT32_VEC3, value);
         }
         return;
      case 93: //up
         {
            float value[] = {0.000000f, 1.000000f, 0.000000f};
            up.set(device, object, ANARI_FLOAT32_VEC3, value);
         }
         return;
      case 91: //transform
         {
            float value[] = {1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f};
            transform.set(device, object, ANARI_FLOAT32_MAT4, value);
         }
         return;
      case 39: //imageRegion
         {
            float value[] = {0.000000f, 0.000000f, 1.000000f, 1.000000f};
            imageRegion.set(device, object, ANARI_FLOAT32_BOX2, value);
         }
         return;
      case 6: //apertureRadius
         {
            float value[] = {0.000000f};
            apertureRadius.set(device, object, ANARI_FLOAT32, value);
         }
         return;
      case 30: //focusDistance
         {
            float value[] = {1.000000f};
            focusDistance.set(device, object, ANARI_FLOAT32, value);
         }
         return;
      case 88: //stereoMode
         {
            const char *value = "none";
            stereoMode.set(device, object, ANARI_STRING, value);
         }
         return;
      case 45: //interpupillaryDistance
         {
            float value[] = {0.063500f};
            interpupillaryDistance.set(device, object, ANARI_FLOAT32, value);
         }
         return;
      case 51: //layout
         {
            const char *value = "equirectangular";
            layout.set(device, object, ANARI_STRING, value);
         }
         return;
      default: // unknown param
         //unknown parameter
         return;
   }
}
ParameterBase& CameraOmnidirectional::operator[](size_t idx) {
   static EmptyParameter empty;
   switch(idx) {
      case 0: return name;
      case 1: return position;
      case 2: return direction;
      case 3: return up;
      case 4: return transform;
      case 5: return imageRegion;
      case 6: return apertureRadius;
      case 7: return focusDistance;
      case 8: return stereoMode;
      case 9: return interpupillaryDistance;
      case 10: return layout;
      default: return empty;
   }
}
ParameterBase& CameraOmnidirectional::operator[](const char *paramname) {
   static EmptyParameter empty;
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: return name;
      case 66: return position;
      case 24: return direction;
      case 93: return up;
      case 91: return transform;
      case 39: return imageRegion;
      case 6: return apertureRadius;
      case 30: return focusDistance;
      case 88: return stereoMode;
      case 45: return interpupillaryDistance;
      case 51: return layout;
      default: return empty;
   }
}
const char ** CameraOmnidirectional::paramNames() const {
   static const char *paramnames[] = {
      "name",
      "position",
      "direction",
      "up",
      "transform",
      "imageRegion",
      "apertureRadius",
      "focusDistance",
      "stereoMode",
      "interpupillaryDistance",
      "layout",
      nullptr
   };
   return paramnames;
}
size_t CameraOmnidirectional::paramCount() const {
   return 11;
}

CameraOrthographic::CameraOrthographic(ANARIDevice device, ANARIObject o) : device(device), object(o) {
   {
      float value[] = {0.000000f, 0.000000f, 0.000000f};
      position.set(device, object, ANARI_FLOAT32_VEC3, value);
   }
   {
      float value[] = {0.000000f, 0.000000f, -1.000000f};
      direction.set(device, object, ANARI_FLOAT32_VEC3, value);
   }
   {
      float value[] = {0.000000f, 1.000000f, 0.000000f};
      up.set(device, object, ANARI_FLOAT32_VEC3, value);
   }
   {
      float value[] = {1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f};
      transform.set(device, object, ANARI_FLOAT32_MAT4, value);
   }
   {
      float value[] = {0.000000f, 0.000000f, 1.000000f, 1.000000f};
      imageRegion.set(device, object, ANARI_FLOAT32_BOX2, value);
   }
   {
      float value[] = {0.000000f};
      apertureRadius.set(device, object, ANARI_FLOAT32, value);
   }
   {
      float value[] = {1.000000f};
      focusDistance.set(device, object, ANARI_FLOAT32, value);
   }
   {
      const char *value = "none";
      stereoMode.set(device, object, ANARI_STRING, value);
   }
   {
      float value[] = {0.063500f};
      interpupillaryDistance.set(device, object, ANARI_FLOAT32, value);
   }
   {
      float value[] = {1.000000f};
      height.set(device, object, ANARI_FLOAT32, value);
   }
   {
      float value[] = {1.000000f};
      aspect.set(device, object, ANARI_FLOAT32, value);
   }
}
bool CameraOrthographic::set(const char *paramname, ANARIDataType type, const void *mem) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: //name
         return name.set(device, object, type, mem);
      case 66: //position
         return position.set(device, object, type, mem);
      case 24: //direction
         return direction.set(device, object, type, mem);
      case 93: //up
         return up.set(device, object, type, mem);
      case 91: //transform
         return transform.set(device, object, type, mem);
      case 39: //imageRegion
         return imageRegion.set(device, object, type, mem);
      case 6: //apertureRadius
         return apertureRadius.set(device, object, type, mem);
      case 30: //focusDistance
         return focusDistance.set(device, object, type, mem);
      case 88: //stereoMode
         return stereoMode.set(device, object, type, mem);
      case 45: //interpupillaryDistance
         return interpupillaryDistance.set(device, object, type, mem);
      case 37: //height
         return height.set(device, object, type, mem);
      case 8: //aspect
         return aspect.set(device, object, type, mem);
      case 56: //near
         return near.set(device, object, type, mem);
      case 27: //far
         return far.set(device, object, type, mem);
      default: // unknown param
         //unknown parameter
         return false;
   }
}
void CameraOrthographic::unset(const char *paramname) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: //name
         name.unset(device, object);
         return;
      case 66: //position
         {
            float value[] = {0.000000f, 0.000000f, 0.000000f};
            position.set(device, object, ANARI_FLOAT32_VEC3, value);
         }
         return;
      case 24: //direction
         {
            float value[] = {0.000000f, 0.000000f, -1.000000f};
            direction.set(device, object, ANARI_FLOAT32_VEC3, value);
         }
         return;
      case 93: //up
         {
            float value[] = {0.000000f, 1.000000f, 0.000000f};
            up.set(device, object, ANARI_FLOAT32_VEC3, value);
         }
         return;
      case 91: //transform
         {
            float value[] = {1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f};
            transform.set(device, object, ANARI_FLOAT32_MAT4, value);
         }
         return;
      case 39: //imageRegion
         {
            float value[] = {0.000000f, 0.000000f, 1.000000f, 1.000000f};
            imageRegion.set(device, object, ANARI_FLOAT32_BOX2, value);
         }
         return;
      case 6: //apertureRadius
         {
            float value[] = {0.000000f};
            apertureRadius.set(device, object, ANARI_FLOAT32, value);
         }
         return;
      case 30: //focusDistance
         {
            float value[] = {1.000000f};
            focusDistance.set(device, object, ANARI_FLOAT32, value);
         }
         return;
      case 88: //stereoMode
         {
            const char *value = "none";
            stereoMode.set(device, object, ANARI_STRING, value);
         }
         return;
      case 45: //interpupillaryDistance
         {
            float value[] = {0.063500f};
            interpupillaryDistance.set(device, object, ANARI_FLOAT32, value);
         }
         return;
      case 37: //height
         {
            float value[] = {1.000000f};
            height.set(device, object, ANARI_FLOAT32, value);
         }
         return;
      case 8: //aspect
         {
            float value[] = {1.000000f};
            aspect.set(device, object, ANARI_FLOAT32, value);
         }
         return;
      case 56: //near
         near.unset(device, object);
         return;
      case 27: //far
         far.unset(device, object);
         return;
      default: // unknown param
         //unknown parameter
         return;
   }
}
ParameterBase& CameraOrthographic::operator[](size_t idx) {
   static EmptyParameter empty;
   switch(idx) {
      case 0: return name;
      case 1: return position;
      case 2: return direction;
      case 3: return up;
      case 4: return transform;
      case 5: return imageRegion;
      case 6: return apertureRadius;
      case 7: return focusDistance;
      case 8: return stereoMode;
      case 9: return interpupillaryDistance;
      case 10: return height;
      case 11: return aspect;
      case 12: return near;
      case 13: return far;
      default: return empty;
   }
}
ParameterBase& CameraOrthographic::operator[](const char *paramname) {
   static EmptyParameter empty;
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: return name;
      case 66: return position;
      case 24: return direction;
      case 93: return up;
      case 91: return transform;
      case 39: return imageRegion;
      case 6: return apertureRadius;
      case 30: return focusDistance;
      case 88: return stereoMode;
      case 45: return interpupillaryDistance;
      case 37: return height;
      case 8: return aspect;
      case 56: return near;
      case 27: return far;
      default: return empty;
   }
}
const char ** CameraOrthographic::paramNames() const {
   static const char *paramnames[] = {
      "name",
      "position",
      "direction",
      "up",
      "transform",
      "imageRegion",
      "apertureRadius",
      "focusDistance",
      "stereoMode",
      "interpupillaryDistance",
      "height",
      "aspect",
      "near",
      "far",
      nullptr
   };
   return paramnames;
}
size_t CameraOrthographic::paramCount() const {
   return 14;
}

CameraPerspective::CameraPerspective(ANARIDevice device, ANARIObject o) : device(device), object(o) {
   {
      float value[] = {0.000000f, 0.000000f, 0.000000f};
      position.set(device, object, ANARI_FLOAT32_VEC3, value);
   }
   {
      float value[] = {0.000000f, 0.000000f, -1.000000f};
      direction.set(device, object, ANARI_FLOAT32_VEC3, value);
   }
   {
      float value[] = {0.000000f, 1.000000f, 0.000000f};
      up.set(device, object, ANARI_FLOAT32_VEC3, value);
   }
   {
      float value[] = {1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f};
      transform.set(device, object, ANARI_FLOAT32_MAT4, value);
   }
   {
      float value[] = {0.000000f, 0.000000f, 1.000000f, 1.000000f};
      imageRegion.set(device, object, ANARI_FLOAT32_BOX2, value);
   }
   {
      float value[] = {0.000000f};
      apertureRadius.set(device, object, ANARI_FLOAT32, value);
   }
   {
      float value[] = {1.000000f};
      focusDistance.set(device, object, ANARI_FLOAT32, value);
   }
   {
      const char *value = "none";
      stereoMode.set(device, object, ANARI_STRING, value);
   }
   {
      float value[] = {0.063500f};
      interpupillaryDistance.set(device, object, ANARI_FLOAT32, value);
   }
   {
      float value[] = {1.047198f};
      fovy.set(device, object, ANARI_FLOAT32, value);
   }
   {
      float value[] = {1.000000f};
      aspect.set(device, object, ANARI_FLOAT32, value);
   }
}
bool CameraPerspective::set(const char *paramname, ANARIDataType type, const void *mem) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: //name
         return name.set(device, object, type, mem);
      case 66: //position
         return position.set(device, object, type, mem);
      case 24: //direction
         return direction.set(device, object, type, mem);
      case 93: //up
         return up.set(device, object, type, mem);
      case 91: //transform
         return transform.set(device, object, type, mem);
      case 39: //imageRegion
         return imageRegion.set(device, object, type, mem);
      case 6: //apertureRadius
         return apertureRadius.set(device, object, type, mem);
      case 30: //focusDistance
         return focusDistance.set(device, object, type, mem);
      case 88: //stereoMode
         return stereoMode.set(device, object, type, mem);
      case 45: //interpupillaryDistance
         return interpupillaryDistance.set(device, object, type, mem);
      case 31: //fovy
         return fovy.set(device, object, type, mem);
      case 8: //aspect
         return aspect.set(device, object, type, mem);
      case 56: //near
         return near.set(device, object, type, mem);
      case 27: //far
         return far.set(device, object, type, mem);
      default: // unknown param
         //unknown parameter
         return false;
   }
}
void CameraPerspective::unset(const char *paramname) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: //name
         name.unset(device, object);
         return;
      case 66: //position
         {
            float value[] = {0.000000f, 0.000000f, 0.000000f};
            position.set(device, object, ANARI_FLOAT32_VEC3, value);
         }
         return;
      case 24: //direction
         {
            float value[] = {0.000000f, 0.000000f, -1.000000f};
            direction.set(device, object, ANARI_FLOAT32_VEC3, value);
         }
         return;
      case 93: //up
         {
            float value[] = {0.000000f, 1.000000f, 0.000000f};
            up.set(device, object, ANARI_FLOAT32_VEC3, value);
         }
         return;
      case 91: //transform
         {
            float value[] = {1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f};
            transform.set(device, object, ANARI_FLOAT32_MAT4, value);
         }
         return;
      case 39: //imageRegion
         {
            float value[] = {0.000000f, 0.000000f, 1.000000f, 1.000000f};
            imageRegion.set(device, object, ANARI_FLOAT32_BOX2, value);
         }
         return;
      case 6: //apertureRadius
         {
            float value[] = {0.000000f};
            apertureRadius.set(device, object, ANARI_FLOAT32, value);
         }
         return;
      case 30: //focusDistance
         {
            float value[] = {1.000000f};
            focusDistance.set(device, object, ANARI_FLOAT32, value);
         }
         return;
      case 88: //stereoMode
         {
            const char *value = "none";
            stereoMode.set(device, object, ANARI_STRING, value);
         }
         return;
      case 45: //interpupillaryDistance
         {
            float value[] = {0.063500f};
            interpupillaryDistance.set(device, object, ANARI_FLOAT32, value);
         }
         return;
      case 31: //fovy
         {
            float value[] = {1.047198f};
            fovy.set(device, object, ANARI_FLOAT32, value);
         }
         return;
      case 8: //aspect
         {
            float value[] = {1.000000f};
            aspect.set(device, object, ANARI_FLOAT32, value);
         }
         return;
      case 56: //near
         near.unset(device, object);
         return;
      case 27: //far
         far.unset(device, object);
         return;
      default: // unknown param
         //unknown parameter
         return;
   }
}
ParameterBase& CameraPerspective::operator[](size_t idx) {
   static EmptyParameter empty;
   switch(idx) {
      case 0: return name;
      case 1: return position;
      case 2: return direction;
      case 3: return up;
      case 4: return transform;
      case 5: return imageRegion;
      case 6: return apertureRadius;
      case 7: return focusDistance;
      case 8: return stereoMode;
      case 9: return interpupillaryDistance;
      case 10: return fovy;
      case 11: return aspect;
      case 12: return near;
      case 13: return far;
      default: return empty;
   }
}
ParameterBase& CameraPerspective::operator[](const char *paramname) {
   static EmptyParameter empty;
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: return name;
      case 66: return position;
      case 24: return direction;
      case 93: return up;
      case 91: return transform;
      case 39: return imageRegion;
      case 6: return apertureRadius;
      case 30: return focusDistance;
      case 88: return stereoMode;
      case 45: return interpupillaryDistance;
      case 31: return fovy;
      case 8: return aspect;
      case 56: return near;
      case 27: return far;
      default: return empty;
   }
}
const char ** CameraPerspective::paramNames() const {
   static const char *paramnames[] = {
      "name",
      "position",
      "direction",
      "up",
      "transform",
      "imageRegion",
      "apertureRadius",
      "focusDistance",
      "stereoMode",
      "interpupillaryDistance",
      "fovy",
      "aspect",
      "near",
      "far",
      nullptr
   };
   return paramnames;
}
size_t CameraPerspective::paramCount() const {
   return 14;
}

GeometryCone::GeometryCone(ANARIDevice device, ANARIObject o) : device(device), object(o) {
   {
      const char *value = "none";
      caps.set(device, object, ANARI_STRING, value);
   }
   {
      const char *value = "device";
      geometryPrecision.set(device, object, ANARI_STRING, value);
   }
}
bool GeometryCone::set(const char *paramname, ANARIDataType type, const void *mem) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: //name
         return name.set(device, object, type, mem);
      case 72: //primitive.color
         return primitive_color.set(device, object, type, mem);
      case 68: //primitive.attribute0
         return primitive_attribute0.set(device, object, type, mem);
      case 69: //primitive.attribute1
         return primitive_attribute1.set(device, object, type, mem);
      case 70: //primitive.attribute2
         return primitive_attribute2.set(device, object, type, mem);
      case 71: //primitive.attribute3
         return primitive_attribute3.set(device, object, type, mem);
      case 73: //primitive.id
         return primitive_id.set(device, object, type, mem);
      case 102: //vertex.position
         return vertex_position.set(device, object, type, mem);
      case 103: //vertex.radius
         return vertex_radius.set(device, object, type, mem);
      case 99: //vertex.cap
         return vertex_cap.set(device, object, type, mem);
      case 100: //vertex.color
         return vertex_color.set(device, object, type, mem);
      case 95: //vertex.attribute0
         return vertex_attribute0.set(device, object, type, mem);
      case 96: //vertex.attribute1
         return vertex_attribute1.set(device, object, type, mem);
      case 97: //vertex.attribute2
         return vertex_attribute2.set(device, object, type, mem);
      case 98: //vertex.attribute3
         return vertex_attribute3.set(device, object, type, mem);
      case 74: //primitive.index
         return primitive_index.set(device, object, type, mem);
      case 14: //caps
         return caps.set(device, object, type, mem);
      case 33: //geometryPrecision
         return geometryPrecision.set(device, object, type, mem);
      default: // unknown param
         //unknown parameter
         return false;
   }
}
void GeometryCone::unset(const char *paramname) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: //name
         name.unset(device, object);
         return;
      case 72: //primitive.color
         primitive_color.unset(device, object);
         return;
      case 68: //primitive.attribute0
         primitive_attribute0.unset(device, object);
         return;
      case 69: //primitive.attribute1
         primitive_attribute1.unset(device, object);
         return;
      case 70: //primitive.attribute2
         primitive_attribute2.unset(device, object);
         return;
      case 71: //primitive.attribute3
         primitive_attribute3.unset(device, object);
         return;
      case 73: //primitive.id
         primitive_id.unset(device, object);
         return;
      case 102: //vertex.position
         vertex_position.unset(device, object);
         return;
      case 103: //vertex.radius
         vertex_radius.unset(device, object);
         return;
      case 99: //vertex.cap
         vertex_cap.unset(device, object);
         return;
      case 100: //vertex.color
         vertex_color.unset(device, object);
         return;
      case 95: //vertex.attribute0
         vertex_attribute0.unset(device, object);
         return;
      case 96: //vertex.attribute1
         vertex_attribute1.unset(device, object);
         return;
      case 97: //vertex.attribute2
         vertex_attribute2.unset(device, object);
         return;
      case 98: //vertex.attribute3
         vertex_attribute3.unset(device, object);
         return;
      case 74: //primitive.index
         primitive_index.unset(device, object);
         return;
      case 14: //caps
         {
            const char *value = "none";
            caps.set(device, object, ANARI_STRING, value);
         }
         return;
      case 33: //geometryPrecision
         {
            const char *value = "device";
            geometryPrecision.set(device, object, ANARI_STRING, value);
         }
         return;
      default: // unknown param
         //unknown parameter
         return;
   }
}
ParameterBase& GeometryCone::operator[](size_t idx) {
   static EmptyParameter empty;
   switch(idx) {
      case 0: return name;
      case 1: return primitive_color;
      case 2: return primitive_attribute0;
      case 3: return primitive_attribute1;
      case 4: return primitive_attribute2;
      case 5: return primitive_attribute3;
      case 6: return primitive_id;
      case 7: return vertex_position;
      case 8: return vertex_radius;
      case 9: return vertex_cap;
      case 10: return vertex_color;
      case 11: return vertex_attribute0;
      case 12: return vertex_attribute1;
      case 13: return vertex_attribute2;
      case 14: return vertex_attribute3;
      case 15: return primitive_index;
      case 16: return caps;
      case 17: return geometryPrecision;
      default: return empty;
   }
}
ParameterBase& GeometryCone::operator[](const char *paramname) {
   static EmptyParameter empty;
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: return name;
      case 72: return primitive_color;
      case 68: return primitive_attribute0;
      case 69: return primitive_attribute1;
      case 70: return primitive_attribute2;
      case 71: return primitive_attribute3;
      case 73: return primitive_id;
      case 102: return vertex_position;
      case 103: return vertex_radius;
      case 99: return vertex_cap;
      case 100: return vertex_color;
      case 95: return vertex_attribute0;
      case 96: return vertex_attribute1;
      case 97: return vertex_attribute2;
      case 98: return vertex_attribute3;
      case 74: return primitive_index;
      case 14: return caps;
      case 33: return geometryPrecision;
      default: return empty;
   }
}
const char ** GeometryCone::paramNames() const {
   static const char *paramnames[] = {
      "name",
      "primitive.color",
      "primitive.attribute0",
      "primitive.attribute1",
      "primitive.attribute2",
      "primitive.attribute3",
      "primitive.id",
      "vertex.position",
      "vertex.radius",
      "vertex.cap",
      "vertex.color",
      "vertex.attribute0",
      "vertex.attribute1",
      "vertex.attribute2",
      "vertex.attribute3",
      "primitive.index",
      "caps",
      "geometryPrecision",
      nullptr
   };
   return paramnames;
}
size_t GeometryCone::paramCount() const {
   return 18;
}

GeometryCurve::GeometryCurve(ANARIDevice device, ANARIObject o) : device(device), object(o) {
}
bool GeometryCurve::set(const char *paramname, ANARIDataType type, const void *mem) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: //name
         return name.set(device, object, type, mem);
      case 72: //primitive.color
         return primitive_color.set(device, object, type, mem);
      case 68: //primitive.attribute0
         return primitive_attribute0.set(device, object, type, mem);
      case 69: //primitive.attribute1
         return primitive_attribute1.set(device, object, type, mem);
      case 70: //primitive.attribute2
         return primitive_attribute2.set(device, object, type, mem);
      case 71: //primitive.attribute3
         return primitive_attribute3.set(device, object, type, mem);
      case 73: //primitive.id
         return primitive_id.set(device, object, type, mem);
      case 102: //vertex.position
         return vertex_position.set(device, object, type, mem);
      case 103: //vertex.radius
         return vertex_radius.set(device, object, type, mem);
      case 100: //vertex.color
         return vertex_color.set(device, object, type, mem);
      case 95: //vertex.attribute0
         return vertex_attribute0.set(device, object, type, mem);
      case 96: //vertex.attribute1
         return vertex_attribute1.set(device, object, type, mem);
      case 97: //vertex.attribute2
         return vertex_attribute2.set(device, object, type, mem);
      case 98: //vertex.attribute3
         return vertex_attribute3.set(device, object, type, mem);
      case 74: //primitive.index
         return primitive_index.set(device, object, type, mem);
      case 76: //radius
         return radius.set(device, object, type, mem);
      default: // unknown param
         //unknown parameter
         return false;
   }
}
void GeometryCurve::unset(const char *paramname) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: //name
         name.unset(device, object);
         return;
      case 72: //primitive.color
         primitive_color.unset(device, object);
         return;
      case 68: //primitive.attribute0
         primitive_attribute0.unset(device, object);
         return;
      case 69: //primitive.attribute1
         primitive_attribute1.unset(device, object);
         return;
      case 70: //primitive.attribute2
         primitive_attribute2.unset(device, object);
         return;
      case 71: //primitive.attribute3
         primitive_attribute3.unset(device, object);
         return;
      case 73: //primitive.id
         primitive_id.unset(device, object);
         return;
      case 102: //vertex.position
         vertex_position.unset(device, object);
         return;
      case 103: //vertex.radius
         vertex_radius.unset(device, object);
         return;
      case 100: //vertex.color
         vertex_color.unset(device, object);
         return;
      case 95: //vertex.attribute0
         vertex_attribute0.unset(device, object);
         return;
      case 96: //vertex.attribute1
         vertex_attribute1.unset(device, object);
         return;
      case 97: //vertex.attribute2
         vertex_attribute2.unset(device, object);
         return;
      case 98: //vertex.attribute3
         vertex_attribute3.unset(device, object);
         return;
      case 74: //primitive.index
         primitive_index.unset(device, object);
         return;
      case 76: //radius
         radius.unset(device, object);
         return;
      default: // unknown param
         //unknown parameter
         return;
   }
}
ParameterBase& GeometryCurve::operator[](size_t idx) {
   static EmptyParameter empty;
   switch(idx) {
      case 0: return name;
      case 1: return primitive_color;
      case 2: return primitive_attribute0;
      case 3: return primitive_attribute1;
      case 4: return primitive_attribute2;
      case 5: return primitive_attribute3;
      case 6: return primitive_id;
      case 7: return vertex_position;
      case 8: return vertex_radius;
      case 9: return vertex_color;
      case 10: return vertex_attribute0;
      case 11: return vertex_attribute1;
      case 12: return vertex_attribute2;
      case 13: return vertex_attribute3;
      case 14: return primitive_index;
      case 15: return radius;
      default: return empty;
   }
}
ParameterBase& GeometryCurve::operator[](const char *paramname) {
   static EmptyParameter empty;
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: return name;
      case 72: return primitive_color;
      case 68: return primitive_attribute0;
      case 69: return primitive_attribute1;
      case 70: return primitive_attribute2;
      case 71: return primitive_attribute3;
      case 73: return primitive_id;
      case 102: return vertex_position;
      case 103: return vertex_radius;
      case 100: return vertex_color;
      case 95: return vertex_attribute0;
      case 96: return vertex_attribute1;
      case 97: return vertex_attribute2;
      case 98: return vertex_attribute3;
      case 74: return primitive_index;
      case 76: return radius;
      default: return empty;
   }
}
const char ** GeometryCurve::paramNames() const {
   static const char *paramnames[] = {
      "name",
      "primitive.color",
      "primitive.attribute0",
      "primitive.attribute1",
      "primitive.attribute2",
      "primitive.attribute3",
      "primitive.id",
      "vertex.position",
      "vertex.radius",
      "vertex.color",
      "vertex.attribute0",
      "vertex.attribute1",
      "vertex.attribute2",
      "vertex.attribute3",
      "primitive.index",
      "radius",
      nullptr
   };
   return paramnames;
}
size_t GeometryCurve::paramCount() const {
   return 16;
}

GeometryCylinder::GeometryCylinder(ANARIDevice device, ANARIObject o) : device(device), object(o) {
   {
      const char *value = "none";
      caps.set(device, object, ANARI_STRING, value);
   }
   {
      const char *value = "device";
      geometryPrecision.set(device, object, ANARI_STRING, value);
   }
}
bool GeometryCylinder::set(const char *paramname, ANARIDataType type, const void *mem) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: //name
         return name.set(device, object, type, mem);
      case 72: //primitive.color
         return primitive_color.set(device, object, type, mem);
      case 68: //primitive.attribute0
         return primitive_attribute0.set(device, object, type, mem);
      case 69: //primitive.attribute1
         return primitive_attribute1.set(device, object, type, mem);
      case 70: //primitive.attribute2
         return primitive_attribute2.set(device, object, type, mem);
      case 71: //primitive.attribute3
         return primitive_attribute3.set(device, object, type, mem);
      case 73: //primitive.id
         return primitive_id.set(device, object, type, mem);
      case 102: //vertex.position
         return vertex_position.set(device, object, type, mem);
      case 99: //vertex.cap
         return vertex_cap.set(device, object, type, mem);
      case 100: //vertex.color
         return vertex_color.set(device, object, type, mem);
      case 95: //vertex.attribute0
         return vertex_attribute0.set(device, object, type, mem);
      case 96: //vertex.attribute1
         return vertex_attribute1.set(device, object, type, mem);
      case 97: //vertex.attribute2
         return vertex_attribute2.set(device, object, type, mem);
      case 98: //vertex.attribute3
         return vertex_attribute3.set(device, object, type, mem);
      case 74: //primitive.index
         return primitive_index.set(device, object, type, mem);
      case 75: //primitive.radius
         return primitive_radius.set(device, object, type, mem);
      case 76: //radius
         return radius.set(device, object, type, mem);
      case 14: //caps
         return caps.set(device, object, type, mem);
      case 33: //geometryPrecision
         return geometryPrecision.set(device, object, type, mem);
      default: // unknown param
         //unknown parameter
         return false;
   }
}
void GeometryCylinder::unset(const char *paramname) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: //name
         name.unset(device, object);
         return;
      case 72: //primitive.color
         primitive_color.unset(device, object);
         return;
      case 68: //primitive.attribute0
         primitive_attribute0.unset(device, object);
         return;
      case 69: //primitive.attribute1
         primitive_attribute1.unset(device, object);
         return;
      case 70: //primitive.attribute2
         primitive_attribute2.unset(device, object);
         return;
      case 71: //primitive.attribute3
         primitive_attribute3.unset(device, object);
         return;
      case 73: //primitive.id
         primitive_id.unset(device, object);
         return;
      case 102: //vertex.position
         vertex_position.unset(device, object);
         return;
      case 99: //vertex.cap
         vertex_cap.unset(device, object);
         return;
      case 100: //vertex.color
         vertex_color.unset(device, object);
         return;
      case 95: //vertex.attribute0
         vertex_attribute0.unset(device, object);
         return;
      case 96: //vertex.attribute1
         vertex_attribute1.unset(device, object);
         return;
      case 97: //vertex.attribute2
         vertex_attribute2.unset(device, object);
         return;
      case 98: //vertex.attribute3
         vertex_attribute3.unset(device, object);
         return;
      case 74: //primitive.index
         primitive_index.unset(device, object);
         return;
      case 75: //primitive.radius
         primitive_radius.unset(device, object);
         return;
      case 76: //radius
         radius.unset(device, object);
         return;
      case 14: //caps
         {
            const char *value = "none";
            caps.set(device, object, ANARI_STRING, value);
         }
         return;
      case 33: //geometryPrecision
         {
            const char *value = "device";
            geometryPrecision.set(device, object, ANARI_STRING, value);
         }
         return;
      default: // unknown param
         //unknown parameter
         return;
   }
}
ParameterBase& GeometryCylinder::operator[](size_t idx) {
   static EmptyParameter empty;
   switch(idx) {
      case 0: return name;
      case 1: return primitive_color;
      case 2: return primitive_attribute0;
      case 3: return primitive_attribute1;
      case 4: return primitive_attribute2;
      case 5: return primitive_attribute3;
      case 6: return primitive_id;
      case 7: return vertex_position;
      case 8: return vertex_cap;
      case 9: return vertex_color;
      case 10: return vertex_attribute0;
      case 11: return vertex_attribute1;
      case 12: return vertex_attribute2;
      case 13: return vertex_attribute3;
      case 14: return primitive_index;
      case 15: return primitive_radius;
      case 16: return radius;
      case 17: return caps;
      case 18: return geometryPrecision;
      default: return empty;
   }
}
ParameterBase& GeometryCylinder::operator[](const char *paramname) {
   static EmptyParameter empty;
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: return name;
      case 72: return primitive_color;
      case 68: return primitive_attribute0;
      case 69: return primitive_attribute1;
      case 70: return primitive_attribute2;
      case 71: return primitive_attribute3;
      case 73: return primitive_id;
      case 102: return vertex_position;
      case 99: return vertex_cap;
      case 100: return vertex_color;
      case 95: return vertex_attribute0;
      case 96: return vertex_attribute1;
      case 97: return vertex_attribute2;
      case 98: return vertex_attribute3;
      case 74: return primitive_index;
      case 75: return primitive_radius;
      case 76: return radius;
      case 14: return caps;
      case 33: return geometryPrecision;
      default: return empty;
   }
}
const char ** GeometryCylinder::paramNames() const {
   static const char *paramnames[] = {
      "name",
      "primitive.color",
      "primitive.attribute0",
      "primitive.attribute1",
      "primitive.attribute2",
      "primitive.attribute3",
      "primitive.id",
      "vertex.position",
      "vertex.cap",
      "vertex.color",
      "vertex.attribute0",
      "vertex.attribute1",
      "vertex.attribute2",
      "vertex.attribute3",
      "primitive.index",
      "primitive.radius",
      "radius",
      "caps",
      "geometryPrecision",
      nullptr
   };
   return paramnames;
}
size_t GeometryCylinder::paramCount() const {
   return 19;
}

GeometryQuad::GeometryQuad(ANARIDevice device, ANARIObject o) : device(device), object(o) {
}
bool GeometryQuad::set(const char *paramname, ANARIDataType type, const void *mem) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: //name
         return name.set(device, object, type, mem);
      case 72: //primitive.color
         return primitive_color.set(device, object, type, mem);
      case 68: //primitive.attribute0
         return primitive_attribute0.set(device, object, type, mem);
      case 69: //primitive.attribute1
         return primitive_attribute1.set(device, object, type, mem);
      case 70: //primitive.attribute2
         return primitive_attribute2.set(device, object, type, mem);
      case 71: //primitive.attribute3
         return primitive_attribute3.set(device, object, type, mem);
      case 73: //primitive.id
         return primitive_id.set(device, object, type, mem);
      case 102: //vertex.position
         return vertex_position.set(device, object, type, mem);
      case 101: //vertex.normal
         return vertex_normal.set(device, object, type, mem);
      case 104: //vertex.tangent
         return vertex_tangent.set(device, object, type, mem);
      case 100: //vertex.color
         return vertex_color.set(device, object, type, mem);
      case 95: //vertex.attribute0
         return vertex_attribute0.set(device, object, type, mem);
      case 96: //vertex.attribute1
         return vertex_attribute1.set(device, object, type, mem);
      case 97: //vertex.attribute2
         return vertex_attribute2.set(device, object, type, mem);
      case 98: //vertex.attribute3
         return vertex_attribute3.set(device, object, type, mem);
      case 74: //primitive.index
         return primitive_index.set(device, object, type, mem);
      default: // unknown param
         //unknown parameter
         return false;
   }
}
void GeometryQuad::unset(const char *paramname) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: //name
         name.unset(device, object);
         return;
      case 72: //primitive.color
         primitive_color.unset(device, object);
         return;
      case 68: //primitive.attribute0
         primitive_attribute0.unset(device, object);
         return;
      case 69: //primitive.attribute1
         primitive_attribute1.unset(device, object);
         return;
      case 70: //primitive.attribute2
         primitive_attribute2.unset(device, object);
         return;
      case 71: //primitive.attribute3
         primitive_attribute3.unset(device, object);
         return;
      case 73: //primitive.id
         primitive_id.unset(device, object);
         return;
      case 102: //vertex.position
         vertex_position.unset(device, object);
         return;
      case 101: //vertex.normal
         vertex_normal.unset(device, object);
         return;
      case 104: //vertex.tangent
         vertex_tangent.unset(device, object);
         return;
      case 100: //vertex.color
         vertex_color.unset(device, object);
         return;
      case 95: //vertex.attribute0
         vertex_attribute0.unset(device, object);
         return;
      case 96: //vertex.attribute1
         vertex_attribute1.unset(device, object);
         return;
      case 97: //vertex.attribute2
         vertex_attribute2.unset(device, object);
         return;
      case 98: //vertex.attribute3
         vertex_attribute3.unset(device, object);
         return;
      case 74: //primitive.index
         primitive_index.unset(device, object);
         return;
      default: // unknown param
         //unknown parameter
         return;
   }
}
ParameterBase& GeometryQuad::operator[](size_t idx) {
   static EmptyParameter empty;
   switch(idx) {
      case 0: return name;
      case 1: return primitive_color;
      case 2: return primitive_attribute0;
      case 3: return primitive_attribute1;
      case 4: return primitive_attribute2;
      case 5: return primitive_attribute3;
      case 6: return primitive_id;
      case 7: return vertex_position;
      case 8: return vertex_normal;
      case 9: return vertex_tangent;
      case 10: return vertex_color;
      case 11: return vertex_attribute0;
      case 12: return vertex_attribute1;
      case 13: return vertex_attribute2;
      case 14: return vertex_attribute3;
      case 15: return primitive_index;
      default: return empty;
   }
}
ParameterBase& GeometryQuad::operator[](const char *paramname) {
   static EmptyParameter empty;
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: return name;
      case 72: return primitive_color;
      case 68: return primitive_attribute0;
      case 69: return primitive_attribute1;
      case 70: return primitive_attribute2;
      case 71: return primitive_attribute3;
      case 73: return primitive_id;
      case 102: return vertex_position;
      case 101: return vertex_normal;
      case 104: return vertex_tangent;
      case 100: return vertex_color;
      case 95: return vertex_attribute0;
      case 96: return vertex_attribute1;
      case 97: return vertex_attribute2;
      case 98: return vertex_attribute3;
      case 74: return primitive_index;
      default: return empty;
   }
}
const char ** GeometryQuad::paramNames() const {
   static const char *paramnames[] = {
      "name",
      "primitive.color",
      "primitive.attribute0",
      "primitive.attribute1",
      "primitive.attribute2",
      "primitive.attribute3",
      "primitive.id",
      "vertex.position",
      "vertex.normal",
      "vertex.tangent",
      "vertex.color",
      "vertex.attribute0",
      "vertex.attribute1",
      "vertex.attribute2",
      "vertex.attribute3",
      "primitive.index",
      nullptr
   };
   return paramnames;
}
size_t GeometryQuad::paramCount() const {
   return 16;
}

GeometrySphere::GeometrySphere(ANARIDevice device, ANARIObject o) : device(device), object(o) {
   {
      const char *value = "device";
      geometryPrecision.set(device, object, ANARI_STRING, value);
   }
}
bool GeometrySphere::set(const char *paramname, ANARIDataType type, const void *mem) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: //name
         return name.set(device, object, type, mem);
      case 72: //primitive.color
         return primitive_color.set(device, object, type, mem);
      case 68: //primitive.attribute0
         return primitive_attribute0.set(device, object, type, mem);
      case 69: //primitive.attribute1
         return primitive_attribute1.set(device, object, type, mem);
      case 70: //primitive.attribute2
         return primitive_attribute2.set(device, object, type, mem);
      case 71: //primitive.attribute3
         return primitive_attribute3.set(device, object, type, mem);
      case 73: //primitive.id
         return primitive_id.set(device, object, type, mem);
      case 102: //vertex.position
         return vertex_position.set(device, object, type, mem);
      case 103: //vertex.radius
         return vertex_radius.set(device, object, type, mem);
      case 100: //vertex.color
         return vertex_color.set(device, object, type, mem);
      case 95: //vertex.attribute0
         return vertex_attribute0.set(device, object, type, mem);
      case 96: //vertex.attribute1
         return vertex_attribute1.set(device, object, type, mem);
      case 97: //vertex.attribute2
         return vertex_attribute2.set(device, object, type, mem);
      case 98: //vertex.attribute3
         return vertex_attribute3.set(device, object, type, mem);
      case 74: //primitive.index
         return primitive_index.set(device, object, type, mem);
      case 76: //radius
         return radius.set(device, object, type, mem);
      case 33: //geometryPrecision
         return geometryPrecision.set(device, object, type, mem);
      default: // unknown param
         //unknown parameter
         return false;
   }
}
void GeometrySphere::unset(const char *paramname) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: //name
         name.unset(device, object);
         return;
      case 72: //primitive.color
         primitive_color.unset(device, object);
         return;
      case 68: //primitive.attribute0
         primitive_attribute0.unset(device, object);
         return;
      case 69: //primitive.attribute1
         primitive_attribute1.unset(device, object);
         return;
      case 70: //primitive.attribute2
         primitive_attribute2.unset(device, object);
         return;
      case 71: //primitive.attribute3
         primitive_attribute3.unset(device, object);
         return;
      case 73: //primitive.id
         primitive_id.unset(device, object);
         return;
      case 102: //vertex.position
         vertex_position.unset(device, object);
         return;
      case 103: //vertex.radius
         vertex_radius.unset(device, object);
         return;
      case 100: //vertex.color
         vertex_color.unset(device, object);
         return;
      case 95: //vertex.attribute0
         vertex_attribute0.unset(device, object);
         return;
      case 96: //vertex.attribute1
         vertex_attribute1.unset(device, object);
         return;
      case 97: //vertex.attribute2
         vertex_attribute2.unset(device, object);
         return;
      case 98: //vertex.attribute3
         vertex_attribute3.unset(device, object);
         return;
      case 74: //primitive.index
         primitive_index.unset(device, object);
         return;
      case 76: //radius
         radius.unset(device, object);
         return;
      case 33: //geometryPrecision
         {
            const char *value = "device";
            geometryPrecision.set(device, object, ANARI_STRING, value);
         }
         return;
      default: // unknown param
         //unknown parameter
         return;
   }
}
ParameterBase& GeometrySphere::operator[](size_t idx) {
   static EmptyParameter empty;
   switch(idx) {
      case 0: return name;
      case 1: return primitive_color;
      case 2: return primitive_attribute0;
      case 3: return primitive_attribute1;
      case 4: return primitive_attribute2;
      case 5: return primitive_attribute3;
      case 6: return primitive_id;
      case 7: return vertex_position;
      case 8: return vertex_radius;
      case 9: return vertex_color;
      case 10: return vertex_attribute0;
      case 11: return vertex_attribute1;
      case 12: return vertex_attribute2;
      case 13: return vertex_attribute3;
      case 14: return primitive_index;
      case 15: return radius;
      case 16: return geometryPrecision;
      default: return empty;
   }
}
ParameterBase& GeometrySphere::operator[](const char *paramname) {
   static EmptyParameter empty;
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: return name;
      case 72: return primitive_color;
      case 68: return primitive_attribute0;
      case 69: return primitive_attribute1;
      case 70: return primitive_attribute2;
      case 71: return primitive_attribute3;
      case 73: return primitive_id;
      case 102: return vertex_position;
      case 103: return vertex_radius;
      case 100: return vertex_color;
      case 95: return vertex_attribute0;
      case 96: return vertex_attribute1;
      case 97: return vertex_attribute2;
      case 98: return vertex_attribute3;
      case 74: return primitive_index;
      case 76: return radius;
      case 33: return geometryPrecision;
      default: return empty;
   }
}
const char ** GeometrySphere::paramNames() const {
   static const char *paramnames[] = {
      "name",
      "primitive.color",
      "primitive.attribute0",
      "primitive.attribute1",
      "primitive.attribute2",
      "primitive.attribute3",
      "primitive.id",
      "vertex.position",
      "vertex.radius",
      "vertex.color",
      "vertex.attribute0",
      "vertex.attribute1",
      "vertex.attribute2",
      "vertex.attribute3",
      "primitive.index",
      "radius",
      "geometryPrecision",
      nullptr
   };
   return paramnames;
}
size_t GeometrySphere::paramCount() const {
   return 17;
}

GeometryTriangle::GeometryTriangle(ANARIDevice device, ANARIObject o) : device(device), object(o) {
}
bool GeometryTriangle::set(const char *paramname, ANARIDataType type, const void *mem) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: //name
         return name.set(device, object, type, mem);
      case 72: //primitive.color
         return primitive_color.set(device, object, type, mem);
      case 68: //primitive.attribute0
         return primitive_attribute0.set(device, object, type, mem);
      case 69: //primitive.attribute1
         return primitive_attribute1.set(device, object, type, mem);
      case 70: //primitive.attribute2
         return primitive_attribute2.set(device, object, type, mem);
      case 71: //primitive.attribute3
         return primitive_attribute3.set(device, object, type, mem);
      case 73: //primitive.id
         return primitive_id.set(device, object, type, mem);
      case 102: //vertex.position
         return vertex_position.set(device, object, type, mem);
      case 101: //vertex.normal
         return vertex_normal.set(device, object, type, mem);
      case 104: //vertex.tangent
         return vertex_tangent.set(device, object, type, mem);
      case 100: //vertex.color
         return vertex_color.set(device, object, type, mem);
      case 95: //vertex.attribute0
         return vertex_attribute0.set(device, object, type, mem);
      case 96: //vertex.attribute1
         return vertex_attribute1.set(device, object, type, mem);
      case 97: //vertex.attribute2
         return vertex_attribute2.set(device, object, type, mem);
      case 98: //vertex.attribute3
         return vertex_attribute3.set(device, object, type, mem);
      case 74: //primitive.index
         return primitive_index.set(device, object, type, mem);
      default: // unknown param
         //unknown parameter
         return false;
   }
}
void GeometryTriangle::unset(const char *paramname) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: //name
         name.unset(device, object);
         return;
      case 72: //primitive.color
         primitive_color.unset(device, object);
         return;
      case 68: //primitive.attribute0
         primitive_attribute0.unset(device, object);
         return;
      case 69: //primitive.attribute1
         primitive_attribute1.unset(device, object);
         return;
      case 70: //primitive.attribute2
         primitive_attribute2.unset(device, object);
         return;
      case 71: //primitive.attribute3
         primitive_attribute3.unset(device, object);
         return;
      case 73: //primitive.id
         primitive_id.unset(device, object);
         return;
      case 102: //vertex.position
         vertex_position.unset(device, object);
         return;
      case 101: //vertex.normal
         vertex_normal.unset(device, object);
         return;
      case 104: //vertex.tangent
         vertex_tangent.unset(device, object);
         return;
      case 100: //vertex.color
         vertex_color.unset(device, object);
         return;
      case 95: //vertex.attribute0
         vertex_attribute0.unset(device, object);
         return;
      case 96: //vertex.attribute1
         vertex_attribute1.unset(device, object);
         return;
      case 97: //vertex.attribute2
         vertex_attribute2.unset(device, object);
         return;
      case 98: //vertex.attribute3
         vertex_attribute3.unset(device, object);
         return;
      case 74: //primitive.index
         primitive_index.unset(device, object);
         return;
      default: // unknown param
         //unknown parameter
         return;
   }
}
ParameterBase& GeometryTriangle::operator[](size_t idx) {
   static EmptyParameter empty;
   switch(idx) {
      case 0: return name;
      case 1: return primitive_color;
      case 2: return primitive_attribute0;
      case 3: return primitive_attribute1;
      case 4: return primitive_attribute2;
      case 5: return primitive_attribute3;
      case 6: return primitive_id;
      case 7: return vertex_position;
      case 8: return vertex_normal;
      case 9: return vertex_tangent;
      case 10: return vertex_color;
      case 11: return vertex_attribute0;
      case 12: return vertex_attribute1;
      case 13: return vertex_attribute2;
      case 14: return vertex_attribute3;
      case 15: return primitive_index;
      default: return empty;
   }
}
ParameterBase& GeometryTriangle::operator[](const char *paramname) {
   static EmptyParameter empty;
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: return name;
      case 72: return primitive_color;
      case 68: return primitive_attribute0;
      case 69: return primitive_attribute1;
      case 70: return primitive_attribute2;
      case 71: return primitive_attribute3;
      case 73: return primitive_id;
      case 102: return vertex_position;
      case 101: return vertex_normal;
      case 104: return vertex_tangent;
      case 100: return vertex_color;
      case 95: return vertex_attribute0;
      case 96: return vertex_attribute1;
      case 97: return vertex_attribute2;
      case 98: return vertex_attribute3;
      case 74: return primitive_index;
      default: return empty;
   }
}
const char ** GeometryTriangle::paramNames() const {
   static const char *paramnames[] = {
      "name",
      "primitive.color",
      "primitive.attribute0",
      "primitive.attribute1",
      "primitive.attribute2",
      "primitive.attribute3",
      "primitive.id",
      "vertex.position",
      "vertex.normal",
      "vertex.tangent",
      "vertex.color",
      "vertex.attribute0",
      "vertex.attribute1",
      "vertex.attribute2",
      "vertex.attribute3",
      "primitive.index",
      nullptr
   };
   return paramnames;
}
size_t GeometryTriangle::paramCount() const {
   return 16;
}

LightDirectional::LightDirectional(ANARIDevice device, ANARIObject o) : device(device), object(o) {
   {
      float value[] = {1.000000f, 1.000000f, 1.000000f};
      color.set(device, object, ANARI_FLOAT32_VEC3, value);
   }
   {
      float value[] = {1.000000f};
      irradiance.set(device, object, ANARI_FLOAT32, value);
   }
   {
      float value[] = {0.000000f, 0.000000f, 1.000000f};
      direction.set(device, object, ANARI_FLOAT32_VEC3, value);
   }
}
bool LightDirectional::set(const char *paramname, ANARIDataType type, const void *mem) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: //name
         return name.set(device, object, type, mem);
      case 20: //color
         return color.set(device, object, type, mem);
      case 50: //irradiance
         return irradiance.set(device, object, type, mem);
      case 24: //direction
         return direction.set(device, object, type, mem);
      default: // unknown param
         //unknown parameter
         return false;
   }
}
void LightDirectional::unset(const char *paramname) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: //name
         name.unset(device, object);
         return;
      case 20: //color
         {
            float value[] = {1.000000f, 1.000000f, 1.000000f};
            color.set(device, object, ANARI_FLOAT32_VEC3, value);
         }
         return;
      case 50: //irradiance
         {
            float value[] = {1.000000f};
            irradiance.set(device, object, ANARI_FLOAT32, value);
         }
         return;
      case 24: //direction
         {
            float value[] = {0.000000f, 0.000000f, 1.000000f};
            direction.set(device, object, ANARI_FLOAT32_VEC3, value);
         }
         return;
      default: // unknown param
         //unknown parameter
         return;
   }
}
ParameterBase& LightDirectional::operator[](size_t idx) {
   static EmptyParameter empty;
   switch(idx) {
      case 0: return name;
      case 1: return color;
      case 2: return irradiance;
      case 3: return direction;
      default: return empty;
   }
}
ParameterBase& LightDirectional::operator[](const char *paramname) {
   static EmptyParameter empty;
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: return name;
      case 20: return color;
      case 50: return irradiance;
      case 24: return direction;
      default: return empty;
   }
}
const char ** LightDirectional::paramNames() const {
   static const char *paramnames[] = {
      "name",
      "color",
      "irradiance",
      "direction",
      nullptr
   };
   return paramnames;
}
size_t LightDirectional::paramCount() const {
   return 4;
}

LightPoint::LightPoint(ANARIDevice device, ANARIObject o) : device(device), object(o) {
   {
      float value[] = {1.000000f, 1.000000f, 1.000000f};
      color.set(device, object, ANARI_FLOAT32_VEC3, value);
   }
   {
      float value[] = {0.000000f, 0.000000f, 0.000000f};
      position.set(device, object, ANARI_FLOAT32_VEC3, value);
   }
   {
      float value[] = {1.000000f};
      intensity.set(device, object, ANARI_FLOAT32, value);
   }
   {
      float value[] = {1.000000f};
      power.set(device, object, ANARI_FLOAT32, value);
   }
}
bool LightPoint::set(const char *paramname, ANARIDataType type, const void *mem) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: //name
         return name.set(device, object, type, mem);
      case 20: //color
         return color.set(device, object, type, mem);
      case 66: //position
         return position.set(device, object, type, mem);
      case 44: //intensity
         return intensity.set(device, object, type, mem);
      case 67: //power
         return power.set(device, object, type, mem);
      default: // unknown param
         //unknown parameter
         return false;
   }
}
void LightPoint::unset(const char *paramname) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: //name
         name.unset(device, object);
         return;
      case 20: //color
         {
            float value[] = {1.000000f, 1.000000f, 1.000000f};
            color.set(device, object, ANARI_FLOAT32_VEC3, value);
         }
         return;
      case 66: //position
         {
            float value[] = {0.000000f, 0.000000f, 0.000000f};
            position.set(device, object, ANARI_FLOAT32_VEC3, value);
         }
         return;
      case 44: //intensity
         {
            float value[] = {1.000000f};
            intensity.set(device, object, ANARI_FLOAT32, value);
         }
         return;
      case 67: //power
         {
            float value[] = {1.000000f};
            power.set(device, object, ANARI_FLOAT32, value);
         }
         return;
      default: // unknown param
         //unknown parameter
         return;
   }
}
ParameterBase& LightPoint::operator[](size_t idx) {
   static EmptyParameter empty;
   switch(idx) {
      case 0: return name;
      case 1: return color;
      case 2: return position;
      case 3: return intensity;
      case 4: return power;
      default: return empty;
   }
}
ParameterBase& LightPoint::operator[](const char *paramname) {
   static EmptyParameter empty;
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: return name;
      case 20: return color;
      case 66: return position;
      case 44: return intensity;
      case 67: return power;
      default: return empty;
   }
}
const char ** LightPoint::paramNames() const {
   static const char *paramnames[] = {
      "name",
      "color",
      "position",
      "intensity",
      "power",
      nullptr
   };
   return paramnames;
}
size_t LightPoint::paramCount() const {
   return 5;
}

LightSpot::LightSpot(ANARIDevice device, ANARIObject o) : device(device), object(o) {
   {
      float value[] = {1.000000f, 1.000000f, 1.000000f};
      color.set(device, object, ANARI_FLOAT32_VEC3, value);
   }
   {
      float value[] = {0.000000f, 0.000000f, 0.000000f};
      position.set(device, object, ANARI_FLOAT32_VEC3, value);
   }
   {
      float value[] = {0.000000f, 0.000000f, -1.000000f};
      direction.set(device, object, ANARI_FLOAT32_VEC3, value);
   }
   {
      float value[] = {3.141593f};
      openingAngle.set(device, object, ANARI_FLOAT32, value);
   }
   {
      float value[] = {0.100000f};
      falloffAngle.set(device, object, ANARI_FLOAT32, value);
   }
   {
      float value[] = {1.000000f};
      intensity.set(device, object, ANARI_FLOAT32, value);
   }
   {
      float value[] = {1.000000f};
      power.set(device, object, ANARI_FLOAT32, value);
   }
}
bool LightSpot::set(const char *paramname, ANARIDataType type, const void *mem) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: //name
         return name.set(device, object, type, mem);
      case 20: //color
         return color.set(device, object, type, mem);
      case 66: //position
         return position.set(device, object, type, mem);
      case 24: //direction
         return direction.set(device, object, type, mem);
      case 62: //openingAngle
         return openingAngle.set(device, object, type, mem);
      case 26: //falloffAngle
         return falloffAngle.set(device, object, type, mem);
      case 44: //intensity
         return intensity.set(device, object, type, mem);
      case 67: //power
         return power.set(device, object, type, mem);
      default: // unknown param
         //unknown parameter
         return false;
   }
}
void LightSpot::unset(const char *paramname) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: //name
         name.unset(device, object);
         return;
      case 20: //color
         {
            float value[] = {1.000000f, 1.000000f, 1.000000f};
            color.set(device, object, ANARI_FLOAT32_VEC3, value);
         }
         return;
      case 66: //position
         {
            float value[] = {0.000000f, 0.000000f, 0.000000f};
            position.set(device, object, ANARI_FLOAT32_VEC3, value);
         }
         return;
      case 24: //direction
         {
            float value[] = {0.000000f, 0.000000f, -1.000000f};
            direction.set(device, object, ANARI_FLOAT32_VEC3, value);
         }
         return;
      case 62: //openingAngle
         {
            float value[] = {3.141593f};
            openingAngle.set(device, object, ANARI_FLOAT32, value);
         }
         return;
      case 26: //falloffAngle
         {
            float value[] = {0.100000f};
            falloffAngle.set(device, object, ANARI_FLOAT32, value);
         }
         return;
      case 44: //intensity
         {
            float value[] = {1.000000f};
            intensity.set(device, object, ANARI_FLOAT32, value);
         }
         return;
      case 67: //power
         {
            float value[] = {1.000000f};
            power.set(device, object, ANARI_FLOAT32, value);
         }
         return;
      default: // unknown param
         //unknown parameter
         return;
   }
}
ParameterBase& LightSpot::operator[](size_t idx) {
   static EmptyParameter empty;
   switch(idx) {
      case 0: return name;
      case 1: return color;
      case 2: return position;
      case 3: return direction;
      case 4: return openingAngle;
      case 5: return falloffAngle;
      case 6: return intensity;
      case 7: return power;
      default: return empty;
   }
}
ParameterBase& LightSpot::operator[](const char *paramname) {
   static EmptyParameter empty;
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: return name;
      case 20: return color;
      case 66: return position;
      case 24: return direction;
      case 62: return openingAngle;
      case 26: return falloffAngle;
      case 44: return intensity;
      case 67: return power;
      default: return empty;
   }
}
const char ** LightSpot::paramNames() const {
   static const char *paramnames[] = {
      "name",
      "color",
      "position",
      "direction",
      "openingAngle",
      "falloffAngle",
      "intensity",
      "power",
      nullptr
   };
   return paramnames;
}
size_t LightSpot::paramCount() const {
   return 8;
}

MaterialMatte::MaterialMatte(ANARIDevice device, ANARIObject o) : device(device), object(o) {
   {
      float value[] = {0.800000f, 0.800000f, 0.800000f};
      color.set(device, object, ANARI_FLOAT32_VEC3, value);
   }
   {
      float value[] = {1.000000f};
      opacity.set(device, object, ANARI_FLOAT32, value);
   }
   {
      const char *value = "opaque";
      alphaMode.set(device, object, ANARI_STRING, value);
   }
   {
      float value[] = {0.500000f};
      alphaCutoff.set(device, object, ANARI_FLOAT32, value);
   }
}
bool MaterialMatte::set(const char *paramname, ANARIDataType type, const void *mem) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: //name
         return name.set(device, object, type, mem);
      case 20: //color
         return color.set(device, object, type, mem);
      case 60: //opacity
         return opacity.set(device, object, type, mem);
      case 3: //alphaMode
         return alphaMode.set(device, object, type, mem);
      case 2: //alphaCutoff
         return alphaCutoff.set(device, object, type, mem);
      default: // unknown param
         //unknown parameter
         return false;
   }
}
void MaterialMatte::unset(const char *paramname) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: //name
         name.unset(device, object);
         return;
      case 20: //color
         {
            float value[] = {0.800000f, 0.800000f, 0.800000f};
            color.set(device, object, ANARI_FLOAT32_VEC3, value);
         }
         return;
      case 60: //opacity
         {
            float value[] = {1.000000f};
            opacity.set(device, object, ANARI_FLOAT32, value);
         }
         return;
      case 3: //alphaMode
         {
            const char *value = "opaque";
            alphaMode.set(device, object, ANARI_STRING, value);
         }
         return;
      case 2: //alphaCutoff
         {
            float value[] = {0.500000f};
            alphaCutoff.set(device, object, ANARI_FLOAT32, value);
         }
         return;
      default: // unknown param
         //unknown parameter
         return;
   }
}
ParameterBase& MaterialMatte::operator[](size_t idx) {
   static EmptyParameter empty;
   switch(idx) {
      case 0: return name;
      case 1: return color;
      case 2: return opacity;
      case 3: return alphaMode;
      case 4: return alphaCutoff;
      default: return empty;
   }
}
ParameterBase& MaterialMatte::operator[](const char *paramname) {
   static EmptyParameter empty;
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: return name;
      case 20: return color;
      case 60: return opacity;
      case 3: return alphaMode;
      case 2: return alphaCutoff;
      default: return empty;
   }
}
const char ** MaterialMatte::paramNames() const {
   static const char *paramnames[] = {
      "name",
      "color",
      "opacity",
      "alphaMode",
      "alphaCutoff",
      nullptr
   };
   return paramnames;
}
size_t MaterialMatte::paramCount() const {
   return 5;
}

MaterialTransparentMatte::MaterialTransparentMatte(ANARIDevice device, ANARIObject o) : device(device), object(o) {
   {
      float value[] = {0.800000f, 0.800000f, 0.800000f};
      color.set(device, object, ANARI_FLOAT32_VEC3, value);
   }
   {
      float value[] = {1.000000f};
      opacity.set(device, object, ANARI_FLOAT32, value);
   }
   {
      const char *value = "opaque";
      alphaMode.set(device, object, ANARI_STRING, value);
   }
   {
      float value[] = {0.500000f};
      alphaCutoff.set(device, object, ANARI_FLOAT32, value);
   }
}
bool MaterialTransparentMatte::set(const char *paramname, ANARIDataType type, const void *mem) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: //name
         return name.set(device, object, type, mem);
      case 20: //color
         return color.set(device, object, type, mem);
      case 60: //opacity
         return opacity.set(device, object, type, mem);
      case 3: //alphaMode
         return alphaMode.set(device, object, type, mem);
      case 2: //alphaCutoff
         return alphaCutoff.set(device, object, type, mem);
      default: // unknown param
         //unknown parameter
         return false;
   }
}
void MaterialTransparentMatte::unset(const char *paramname) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: //name
         name.unset(device, object);
         return;
      case 20: //color
         {
            float value[] = {0.800000f, 0.800000f, 0.800000f};
            color.set(device, object, ANARI_FLOAT32_VEC3, value);
         }
         return;
      case 60: //opacity
         {
            float value[] = {1.000000f};
            opacity.set(device, object, ANARI_FLOAT32, value);
         }
         return;
      case 3: //alphaMode
         {
            const char *value = "opaque";
            alphaMode.set(device, object, ANARI_STRING, value);
         }
         return;
      case 2: //alphaCutoff
         {
            float value[] = {0.500000f};
            alphaCutoff.set(device, object, ANARI_FLOAT32, value);
         }
         return;
      default: // unknown param
         //unknown parameter
         return;
   }
}
ParameterBase& MaterialTransparentMatte::operator[](size_t idx) {
   static EmptyParameter empty;
   switch(idx) {
      case 0: return name;
      case 1: return color;
      case 2: return opacity;
      case 3: return alphaMode;
      case 4: return alphaCutoff;
      default: return empty;
   }
}
ParameterBase& MaterialTransparentMatte::operator[](const char *paramname) {
   static EmptyParameter empty;
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: return name;
      case 20: return color;
      case 60: return opacity;
      case 3: return alphaMode;
      case 2: return alphaCutoff;
      default: return empty;
   }
}
const char ** MaterialTransparentMatte::paramNames() const {
   static const char *paramnames[] = {
      "name",
      "color",
      "opacity",
      "alphaMode",
      "alphaCutoff",
      nullptr
   };
   return paramnames;
}
size_t MaterialTransparentMatte::paramCount() const {
   return 5;
}

SamplerImage1D::SamplerImage1D(ANARIDevice device, ANARIObject o) : device(device), object(o) {
   {
      const char *value = "attribute0";
      inAttribute.set(device, object, ANARI_STRING, value);
   }
   {
      const char *value = "nearest";
      filter.set(device, object, ANARI_STRING, value);
   }
   {
      const char *value = "clampToEdge";
      wrapMode1.set(device, object, ANARI_STRING, value);
   }
   {
      float value[] = {1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f};
      inTransform.set(device, object, ANARI_FLOAT32_MAT4, value);
   }
   {
      float value[] = {0.000000f, 0.000000f, 0.000000f, 0.000000f};
      inOffset.set(device, object, ANARI_FLOAT32_VEC4, value);
   }
   {
      float value[] = {1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f};
      outTransform.set(device, object, ANARI_FLOAT32_MAT4, value);
   }
   {
      float value[] = {0.000000f, 0.000000f, 0.000000f, 0.000000f};
      outOffset.set(device, object, ANARI_FLOAT32_VEC4, value);
   }
}
bool SamplerImage1D::set(const char *paramname, ANARIDataType type, const void *mem) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: //name
         return name.set(device, object, type, mem);
      case 38: //image
         return image.set(device, object, type, mem);
      case 40: //inAttribute
         return inAttribute.set(device, object, type, mem);
      case 29: //filter
         return filter.set(device, object, type, mem);
      case 107: //wrapMode1
         return wrapMode1.set(device, object, type, mem);
      case 42: //inTransform
         return inTransform.set(device, object, type, mem);
      case 41: //inOffset
         return inOffset.set(device, object, type, mem);
      case 65: //outTransform
         return outTransform.set(device, object, type, mem);
      case 64: //outOffset
         return outOffset.set(device, object, type, mem);
      default: // unknown param
         //unknown parameter
         return false;
   }
}
void SamplerImage1D::unset(const char *paramname) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: //name
         name.unset(device, object);
         return;
      case 38: //image
         image.unset(device, object);
         return;
      case 40: //inAttribute
         {
            const char *value = "attribute0";
            inAttribute.set(device, object, ANARI_STRING, value);
         }
         return;
      case 29: //filter
         {
            const char *value = "nearest";
            filter.set(device, object, ANARI_STRING, value);
         }
         return;
      case 107: //wrapMode1
         {
            const char *value = "clampToEdge";
            wrapMode1.set(device, object, ANARI_STRING, value);
         }
         return;
      case 42: //inTransform
         {
            float value[] = {1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f};
            inTransform.set(device, object, ANARI_FLOAT32_MAT4, value);
         }
         return;
      case 41: //inOffset
         {
            float value[] = {0.000000f, 0.000000f, 0.000000f, 0.000000f};
            inOffset.set(device, object, ANARI_FLOAT32_VEC4, value);
         }
         return;
      case 65: //outTransform
         {
            float value[] = {1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f};
            outTransform.set(device, object, ANARI_FLOAT32_MAT4, value);
         }
         return;
      case 64: //outOffset
         {
            float value[] = {0.000000f, 0.000000f, 0.000000f, 0.000000f};
            outOffset.set(device, object, ANARI_FLOAT32_VEC4, value);
         }
         return;
      default: // unknown param
         //unknown parameter
         return;
   }
}
ParameterBase& SamplerImage1D::operator[](size_t idx) {
   static EmptyParameter empty;
   switch(idx) {
      case 0: return name;
      case 1: return image;
      case 2: return inAttribute;
      case 3: return filter;
      case 4: return wrapMode1;
      case 5: return inTransform;
      case 6: return inOffset;
      case 7: return outTransform;
      case 8: return outOffset;
      default: return empty;
   }
}
ParameterBase& SamplerImage1D::operator[](const char *paramname) {
   static EmptyParameter empty;
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: return name;
      case 38: return image;
      case 40: return inAttribute;
      case 29: return filter;
      case 107: return wrapMode1;
      case 42: return inTransform;
      case 41: return inOffset;
      case 65: return outTransform;
      case 64: return outOffset;
      default: return empty;
   }
}
const char ** SamplerImage1D::paramNames() const {
   static const char *paramnames[] = {
      "name",
      "image",
      "inAttribute",
      "filter",
      "wrapMode1",
      "inTransform",
      "inOffset",
      "outTransform",
      "outOffset",
      nullptr
   };
   return paramnames;
}
size_t SamplerImage1D::paramCount() const {
   return 9;
}

SamplerImage2D::SamplerImage2D(ANARIDevice device, ANARIObject o) : device(device), object(o) {
   {
      const char *value = "attribute0";
      inAttribute.set(device, object, ANARI_STRING, value);
   }
   {
      const char *value = "nearest";
      filter.set(device, object, ANARI_STRING, value);
   }
   {
      const char *value = "clampToEdge";
      wrapMode1.set(device, object, ANARI_STRING, value);
   }
   {
      const char *value = "clampToEdge";
      wrapMode2.set(device, object, ANARI_STRING, value);
   }
   {
      float value[] = {1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f};
      inTransform.set(device, object, ANARI_FLOAT32_MAT4, value);
   }
   {
      float value[] = {0.000000f, 0.000000f, 0.000000f, 0.000000f};
      inOffset.set(device, object, ANARI_FLOAT32_VEC4, value);
   }
   {
      float value[] = {1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f};
      outTransform.set(device, object, ANARI_FLOAT32_MAT4, value);
   }
   {
      float value[] = {0.000000f, 0.000000f, 0.000000f, 0.000000f};
      outOffset.set(device, object, ANARI_FLOAT32_VEC4, value);
   }
}
bool SamplerImage2D::set(const char *paramname, ANARIDataType type, const void *mem) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: //name
         return name.set(device, object, type, mem);
      case 38: //image
         return image.set(device, object, type, mem);
      case 40: //inAttribute
         return inAttribute.set(device, object, type, mem);
      case 29: //filter
         return filter.set(device, object, type, mem);
      case 107: //wrapMode1
         return wrapMode1.set(device, object, type, mem);
      case 108: //wrapMode2
         return wrapMode2.set(device, object, type, mem);
      case 42: //inTransform
         return inTransform.set(device, object, type, mem);
      case 41: //inOffset
         return inOffset.set(device, object, type, mem);
      case 65: //outTransform
         return outTransform.set(device, object, type, mem);
      case 64: //outOffset
         return outOffset.set(device, object, type, mem);
      default: // unknown param
         //unknown parameter
         return false;
   }
}
void SamplerImage2D::unset(const char *paramname) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: //name
         name.unset(device, object);
         return;
      case 38: //image
         image.unset(device, object);
         return;
      case 40: //inAttribute
         {
            const char *value = "attribute0";
            inAttribute.set(device, object, ANARI_STRING, value);
         }
         return;
      case 29: //filter
         {
            const char *value = "nearest";
            filter.set(device, object, ANARI_STRING, value);
         }
         return;
      case 107: //wrapMode1
         {
            const char *value = "clampToEdge";
            wrapMode1.set(device, object, ANARI_STRING, value);
         }
         return;
      case 108: //wrapMode2
         {
            const char *value = "clampToEdge";
            wrapMode2.set(device, object, ANARI_STRING, value);
         }
         return;
      case 42: //inTransform
         {
            float value[] = {1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f};
            inTransform.set(device, object, ANARI_FLOAT32_MAT4, value);
         }
         return;
      case 41: //inOffset
         {
            float value[] = {0.000000f, 0.000000f, 0.000000f, 0.000000f};
            inOffset.set(device, object, ANARI_FLOAT32_VEC4, value);
         }
         return;
      case 65: //outTransform
         {
            float value[] = {1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f};
            outTransform.set(device, object, ANARI_FLOAT32_MAT4, value);
         }
         return;
      case 64: //outOffset
         {
            float value[] = {0.000000f, 0.000000f, 0.000000f, 0.000000f};
            outOffset.set(device, object, ANARI_FLOAT32_VEC4, value);
         }
         return;
      default: // unknown param
         //unknown parameter
         return;
   }
}
ParameterBase& SamplerImage2D::operator[](size_t idx) {
   static EmptyParameter empty;
   switch(idx) {
      case 0: return name;
      case 1: return image;
      case 2: return inAttribute;
      case 3: return filter;
      case 4: return wrapMode1;
      case 5: return wrapMode2;
      case 6: return inTransform;
      case 7: return inOffset;
      case 8: return outTransform;
      case 9: return outOffset;
      default: return empty;
   }
}
ParameterBase& SamplerImage2D::operator[](const char *paramname) {
   static EmptyParameter empty;
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: return name;
      case 38: return image;
      case 40: return inAttribute;
      case 29: return filter;
      case 107: return wrapMode1;
      case 108: return wrapMode2;
      case 42: return inTransform;
      case 41: return inOffset;
      case 65: return outTransform;
      case 64: return outOffset;
      default: return empty;
   }
}
const char ** SamplerImage2D::paramNames() const {
   static const char *paramnames[] = {
      "name",
      "image",
      "inAttribute",
      "filter",
      "wrapMode1",
      "wrapMode2",
      "inTransform",
      "inOffset",
      "outTransform",
      "outOffset",
      nullptr
   };
   return paramnames;
}
size_t SamplerImage2D::paramCount() const {
   return 10;
}

SamplerImage3D::SamplerImage3D(ANARIDevice device, ANARIObject o) : device(device), object(o) {
   {
      const char *value = "attribute0";
      inAttribute.set(device, object, ANARI_STRING, value);
   }
   {
      const char *value = "nearest";
      filter.set(device, object, ANARI_STRING, value);
   }
   {
      const char *value = "clampToEdge";
      wrapMode1.set(device, object, ANARI_STRING, value);
   }
   {
      const char *value = "clampToEdge";
      wrapMode2.set(device, object, ANARI_STRING, value);
   }
   {
      const char *value = "clampToEdge";
      wrapMode3.set(device, object, ANARI_STRING, value);
   }
   {
      float value[] = {1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f};
      inTransform.set(device, object, ANARI_FLOAT32_MAT4, value);
   }
   {
      float value[] = {0.000000f, 0.000000f, 0.000000f, 0.000000f};
      inOffset.set(device, object, ANARI_FLOAT32_VEC4, value);
   }
   {
      float value[] = {1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f};
      outTransform.set(device, object, ANARI_FLOAT32_MAT4, value);
   }
   {
      float value[] = {0.000000f, 0.000000f, 0.000000f, 0.000000f};
      outOffset.set(device, object, ANARI_FLOAT32_VEC4, value);
   }
}
bool SamplerImage3D::set(const char *paramname, ANARIDataType type, const void *mem) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: //name
         return name.set(device, object, type, mem);
      case 38: //image
         return image.set(device, object, type, mem);
      case 40: //inAttribute
         return inAttribute.set(device, object, type, mem);
      case 29: //filter
         return filter.set(device, object, type, mem);
      case 107: //wrapMode1
         return wrapMode1.set(device, object, type, mem);
      case 108: //wrapMode2
         return wrapMode2.set(device, object, type, mem);
      case 109: //wrapMode3
         return wrapMode3.set(device, object, type, mem);
      case 42: //inTransform
         return inTransform.set(device, object, type, mem);
      case 41: //inOffset
         return inOffset.set(device, object, type, mem);
      case 65: //outTransform
         return outTransform.set(device, object, type, mem);
      case 64: //outOffset
         return outOffset.set(device, object, type, mem);
      default: // unknown param
         //unknown parameter
         return false;
   }
}
void SamplerImage3D::unset(const char *paramname) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: //name
         name.unset(device, object);
         return;
      case 38: //image
         image.unset(device, object);
         return;
      case 40: //inAttribute
         {
            const char *value = "attribute0";
            inAttribute.set(device, object, ANARI_STRING, value);
         }
         return;
      case 29: //filter
         {
            const char *value = "nearest";
            filter.set(device, object, ANARI_STRING, value);
         }
         return;
      case 107: //wrapMode1
         {
            const char *value = "clampToEdge";
            wrapMode1.set(device, object, ANARI_STRING, value);
         }
         return;
      case 108: //wrapMode2
         {
            const char *value = "clampToEdge";
            wrapMode2.set(device, object, ANARI_STRING, value);
         }
         return;
      case 109: //wrapMode3
         {
            const char *value = "clampToEdge";
            wrapMode3.set(device, object, ANARI_STRING, value);
         }
         return;
      case 42: //inTransform
         {
            float value[] = {1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f};
            inTransform.set(device, object, ANARI_FLOAT32_MAT4, value);
         }
         return;
      case 41: //inOffset
         {
            float value[] = {0.000000f, 0.000000f, 0.000000f, 0.000000f};
            inOffset.set(device, object, ANARI_FLOAT32_VEC4, value);
         }
         return;
      case 65: //outTransform
         {
            float value[] = {1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f};
            outTransform.set(device, object, ANARI_FLOAT32_MAT4, value);
         }
         return;
      case 64: //outOffset
         {
            float value[] = {0.000000f, 0.000000f, 0.000000f, 0.000000f};
            outOffset.set(device, object, ANARI_FLOAT32_VEC4, value);
         }
         return;
      default: // unknown param
         //unknown parameter
         return;
   }
}
ParameterBase& SamplerImage3D::operator[](size_t idx) {
   static EmptyParameter empty;
   switch(idx) {
      case 0: return name;
      case 1: return image;
      case 2: return inAttribute;
      case 3: return filter;
      case 4: return wrapMode1;
      case 5: return wrapMode2;
      case 6: return wrapMode3;
      case 7: return inTransform;
      case 8: return inOffset;
      case 9: return outTransform;
      case 10: return outOffset;
      default: return empty;
   }
}
ParameterBase& SamplerImage3D::operator[](const char *paramname) {
   static EmptyParameter empty;
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: return name;
      case 38: return image;
      case 40: return inAttribute;
      case 29: return filter;
      case 107: return wrapMode1;
      case 108: return wrapMode2;
      case 109: return wrapMode3;
      case 42: return inTransform;
      case 41: return inOffset;
      case 65: return outTransform;
      case 64: return outOffset;
      default: return empty;
   }
}
const char ** SamplerImage3D::paramNames() const {
   static const char *paramnames[] = {
      "name",
      "image",
      "inAttribute",
      "filter",
      "wrapMode1",
      "wrapMode2",
      "wrapMode3",
      "inTransform",
      "inOffset",
      "outTransform",
      "outOffset",
      nullptr
   };
   return paramnames;
}
size_t SamplerImage3D::paramCount() const {
   return 11;
}

SamplerPrimitive::SamplerPrimitive(ANARIDevice device, ANARIObject o) : device(device), object(o) {
   {
      uint64_t value[] = {UINT64_C(0)};
      inOffset.set(device, object, ANARI_UINT64, value);
   }
}
bool SamplerPrimitive::set(const char *paramname, ANARIDataType type, const void *mem) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: //name
         return name.set(device, object, type, mem);
      case 7: //array
         return array.set(device, object, type, mem);
      case 41: //inOffset
         return inOffset.set(device, object, type, mem);
      default: // unknown param
         //unknown parameter
         return false;
   }
}
void SamplerPrimitive::unset(const char *paramname) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: //name
         name.unset(device, object);
         return;
      case 7: //array
         array.unset(device, object);
         return;
      case 41: //inOffset
         {
            uint64_t value[] = {UINT64_C(0)};
            inOffset.set(device, object, ANARI_UINT64, value);
         }
         return;
      default: // unknown param
         //unknown parameter
         return;
   }
}
ParameterBase& SamplerPrimitive::operator[](size_t idx) {
   static EmptyParameter empty;
   switch(idx) {
      case 0: return name;
      case 1: return array;
      case 2: return inOffset;
      default: return empty;
   }
}
ParameterBase& SamplerPrimitive::operator[](const char *paramname) {
   static EmptyParameter empty;
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: return name;
      case 7: return array;
      case 41: return inOffset;
      default: return empty;
   }
}
const char ** SamplerPrimitive::paramNames() const {
   static const char *paramnames[] = {
      "name",
      "array",
      "inOffset",
      nullptr
   };
   return paramnames;
}
size_t SamplerPrimitive::paramCount() const {
   return 3;
}

SamplerTransform::SamplerTransform(ANARIDevice device, ANARIObject o) : device(device), object(o) {
   {
      const char *value = "attribute0";
      inAttribute.set(device, object, ANARI_STRING, value);
   }
   {
      float value[] = {1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f};
      outTransform.set(device, object, ANARI_FLOAT32_MAT4, value);
   }
   {
      float value[] = {0.000000f, 0.000000f, 0.000000f, 0.000000f};
      outOffset.set(device, object, ANARI_FLOAT32_MAT4, value);
   }
}
bool SamplerTransform::set(const char *paramname, ANARIDataType type, const void *mem) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: //name
         return name.set(device, object, type, mem);
      case 40: //inAttribute
         return inAttribute.set(device, object, type, mem);
      case 65: //outTransform
         return outTransform.set(device, object, type, mem);
      case 64: //outOffset
         return outOffset.set(device, object, type, mem);
      default: // unknown param
         //unknown parameter
         return false;
   }
}
void SamplerTransform::unset(const char *paramname) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: //name
         name.unset(device, object);
         return;
      case 40: //inAttribute
         {
            const char *value = "attribute0";
            inAttribute.set(device, object, ANARI_STRING, value);
         }
         return;
      case 65: //outTransform
         {
            float value[] = {1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f};
            outTransform.set(device, object, ANARI_FLOAT32_MAT4, value);
         }
         return;
      case 64: //outOffset
         {
            float value[] = {0.000000f, 0.000000f, 0.000000f, 0.000000f};
            outOffset.set(device, object, ANARI_FLOAT32_MAT4, value);
         }
         return;
      default: // unknown param
         //unknown parameter
         return;
   }
}
ParameterBase& SamplerTransform::operator[](size_t idx) {
   static EmptyParameter empty;
   switch(idx) {
      case 0: return name;
      case 1: return inAttribute;
      case 2: return outTransform;
      case 3: return outOffset;
      default: return empty;
   }
}
ParameterBase& SamplerTransform::operator[](const char *paramname) {
   static EmptyParameter empty;
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: return name;
      case 40: return inAttribute;
      case 65: return outTransform;
      case 64: return outOffset;
      default: return empty;
   }
}
const char ** SamplerTransform::paramNames() const {
   static const char *paramnames[] = {
      "name",
      "inAttribute",
      "outTransform",
      "outOffset",
      nullptr
   };
   return paramnames;
}
size_t SamplerTransform::paramCount() const {
   return 4;
}

Spatial_FieldStructuredRegular::Spatial_FieldStructuredRegular(ANARIDevice device, ANARIObject o) : device(device), object(o) {
   {
      float value[] = {0.000000f, 0.000000f, 0.000000f};
      origin.set(device, object, ANARI_FLOAT32_VEC3, value);
   }
   {
      float value[] = {1.000000f, 1.000000f, 1.000000f};
      spacing.set(device, object, ANARI_FLOAT32_VEC3, value);
   }
   {
      const char *value = "linear";
      filter.set(device, object, ANARI_STRING, value);
   }
}
bool Spatial_FieldStructuredRegular::set(const char *paramname, ANARIDataType type, const void *mem) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: //name
         return name.set(device, object, type, mem);
      case 22: //data
         return data.set(device, object, type, mem);
      case 63: //origin
         return origin.set(device, object, type, mem);
      case 83: //spacing
         return spacing.set(device, object, type, mem);
      case 29: //filter
         return filter.set(device, object, type, mem);
      default: // unknown param
         //unknown parameter
         return false;
   }
}
void Spatial_FieldStructuredRegular::unset(const char *paramname) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: //name
         name.unset(device, object);
         return;
      case 22: //data
         data.unset(device, object);
         return;
      case 63: //origin
         {
            float value[] = {0.000000f, 0.000000f, 0.000000f};
            origin.set(device, object, ANARI_FLOAT32_VEC3, value);
         }
         return;
      case 83: //spacing
         {
            float value[] = {1.000000f, 1.000000f, 1.000000f};
            spacing.set(device, object, ANARI_FLOAT32_VEC3, value);
         }
         return;
      case 29: //filter
         {
            const char *value = "linear";
            filter.set(device, object, ANARI_STRING, value);
         }
         return;
      default: // unknown param
         //unknown parameter
         return;
   }
}
ParameterBase& Spatial_FieldStructuredRegular::operator[](size_t idx) {
   static EmptyParameter empty;
   switch(idx) {
      case 0: return name;
      case 1: return data;
      case 2: return origin;
      case 3: return spacing;
      case 4: return filter;
      default: return empty;
   }
}
ParameterBase& Spatial_FieldStructuredRegular::operator[](const char *paramname) {
   static EmptyParameter empty;
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: return name;
      case 22: return data;
      case 63: return origin;
      case 83: return spacing;
      case 29: return filter;
      default: return empty;
   }
}
const char ** Spatial_FieldStructuredRegular::paramNames() const {
   static const char *paramnames[] = {
      "name",
      "data",
      "origin",
      "spacing",
      "filter",
      nullptr
   };
   return paramnames;
}
size_t Spatial_FieldStructuredRegular::paramCount() const {
   return 5;
}

VolumeTransferFunction1D::VolumeTransferFunction1D(ANARIDevice device, ANARIObject o) : device(device), object(o) {
   {
      float value[] = {0.000000f, 1.000000f};
      valueRange.set(device, object, ANARI_FLOAT32_BOX1, value);
   }
   {
      float value[] = {1.000000f};
      densityScale.set(device, object, ANARI_FLOAT32, value);
   }
}
bool VolumeTransferFunction1D::set(const char *paramname, ANARIDataType type, const void *mem) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: //name
         return name.set(device, object, type, mem);
      case 28: //field
         return field.set(device, object, type, mem);
      case 94: //valueRange
         return valueRange.set(device, object, type, mem);
      case 20: //color
         return color.set(device, object, type, mem);
      case 21: //color.position
         return color_position.set(device, object, type, mem);
      case 60: //opacity
         return opacity.set(device, object, type, mem);
      case 61: //opacity.position
         return opacity_position.set(device, object, type, mem);
      case 23: //densityScale
         return densityScale.set(device, object, type, mem);
      default: // unknown param
         //unknown parameter
         return false;
   }
}
void VolumeTransferFunction1D::unset(const char *paramname) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: //name
         name.unset(device, object);
         return;
      case 28: //field
         field.unset(device, object);
         return;
      case 94: //valueRange
         {
            float value[] = {0.000000f, 1.000000f};
            valueRange.set(device, object, ANARI_FLOAT32_BOX1, value);
         }
         return;
      case 20: //color
         color.unset(device, object);
         return;
      case 21: //color.position
         color_position.unset(device, object);
         return;
      case 60: //opacity
         opacity.unset(device, object);
         return;
      case 61: //opacity.position
         opacity_position.unset(device, object);
         return;
      case 23: //densityScale
         {
            float value[] = {1.000000f};
            densityScale.set(device, object, ANARI_FLOAT32, value);
         }
         return;
      default: // unknown param
         //unknown parameter
         return;
   }
}
ParameterBase& VolumeTransferFunction1D::operator[](size_t idx) {
   static EmptyParameter empty;
   switch(idx) {
      case 0: return name;
      case 1: return field;
      case 2: return valueRange;
      case 3: return color;
      case 4: return color_position;
      case 5: return opacity;
      case 6: return opacity_position;
      case 7: return densityScale;
      default: return empty;
   }
}
ParameterBase& VolumeTransferFunction1D::operator[](const char *paramname) {
   static EmptyParameter empty;
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: return name;
      case 28: return field;
      case 94: return valueRange;
      case 20: return color;
      case 21: return color_position;
      case 60: return opacity;
      case 61: return opacity_position;
      case 23: return densityScale;
      default: return empty;
   }
}
const char ** VolumeTransferFunction1D::paramNames() const {
   static const char *paramnames[] = {
      "name",
      "field",
      "valueRange",
      "color",
      "color.position",
      "opacity",
      "opacity.position",
      "densityScale",
      nullptr
   };
   return paramnames;
}
size_t VolumeTransferFunction1D::paramCount() const {
   return 8;
}

MaterialPhysicallyBased::MaterialPhysicallyBased(ANARIDevice device, ANARIObject o) : device(device), object(o) {
   {
      float value[] = {1.000000f, 1.000000f, 1.000000f};
      baseColor.set(device, object, ANARI_FLOAT32_VEC3, value);
   }
   {
      float value[] = {1.000000f};
      opacity.set(device, object, ANARI_FLOAT32, value);
   }
   {
      float value[] = {1.000000f};
      metallic.set(device, object, ANARI_FLOAT32, value);
   }
   {
      float value[] = {1.000000f};
      roughness.set(device, object, ANARI_FLOAT32, value);
   }
   {
      float value[] = {0.000000f, 0.000000f, 0.000000f};
      emissive.set(device, object, ANARI_FLOAT32_VEC3, value);
   }
   {
      const char *value = "opaque";
      alphaMode.set(device, object, ANARI_STRING, value);
   }
   {
      float value[] = {0.500000f};
      alphaCutoff.set(device, object, ANARI_FLOAT32, value);
   }
   {
      float value[] = {0.000000f};
      specular.set(device, object, ANARI_FLOAT32, value);
   }
   {
      float value[] = {1.000000f, 1.000000f, 1.000000f};
      specularColor.set(device, object, ANARI_FLOAT32_VEC3, value);
   }
   {
      float value[] = {0.000000f};
      clearcoat.set(device, object, ANARI_FLOAT32, value);
   }
   {
      float value[] = {0.000000f};
      clearcoatRoughness.set(device, object, ANARI_FLOAT32, value);
   }
   {
      float value[] = {0.000000f};
      transmission.set(device, object, ANARI_FLOAT32, value);
   }
   {
      float value[] = {1.500000f};
      ior.set(device, object, ANARI_FLOAT32, value);
   }
   {
      float value[] = {0.000000f};
      thickness.set(device, object, ANARI_FLOAT32, value);
   }
   {
      const char *value = "INFINITY";
      attenuationDistance.set(device, object, ANARI_FLOAT32, value);
   }
   {
      float value[] = {1.000000f, 1.000000f, 1.000000f};
      attenuationColor.set(device, object, ANARI_FLOAT32_VEC3, value);
   }
   {
      float value[] = {0.000000f, 0.000000f, 0.000000f};
      sheenColor.set(device, object, ANARI_FLOAT32_VEC3, value);
   }
   {
      float value[] = {0.000000f};
      sheenRoughness.set(device, object, ANARI_FLOAT32, value);
   }
   {
      float value[] = {0.000000f};
      iridescence.set(device, object, ANARI_FLOAT32, value);
   }
   {
      float value[] = {1.300000f};
      iridescenceIor.set(device, object, ANARI_FLOAT32, value);
   }
   {
      float value[] = {0.000000f};
      iridescenceThickness.set(device, object, ANARI_FLOAT32, value);
   }
}
bool MaterialPhysicallyBased::set(const char *paramname, ANARIDataType type, const void *mem) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: //name
         return name.set(device, object, type, mem);
      case 12: //baseColor
         return baseColor.set(device, object, type, mem);
      case 60: //opacity
         return opacity.set(device, object, type, mem);
      case 54: //metallic
         return metallic.set(device, object, type, mem);
      case 78: //roughness
         return roughness.set(device, object, type, mem);
      case 57: //normal
         return normal.set(device, object, type, mem);
      case 25: //emissive
         return emissive.set(device, object, type, mem);
      case 58: //occlusion
         return occlusion.set(device, object, type, mem);
      case 3: //alphaMode
         return alphaMode.set(device, object, type, mem);
      case 2: //alphaCutoff
         return alphaCutoff.set(device, object, type, mem);
      case 84: //specular
         return specular.set(device, object, type, mem);
      case 85: //specularColor
         return specularColor.set(device, object, type, mem);
      case 17: //clearcoat
         return clearcoat.set(device, object, type, mem);
      case 19: //clearcoatRoughness
         return clearcoatRoughness.set(device, object, type, mem);
      case 18: //clearcoatNormal
         return clearcoatNormal.set(device, object, type, mem);
      case 92: //transmission
         return transmission.set(device, object, type, mem);
      case 46: //ior
         return ior.set(device, object, type, mem);
      case 90: //thickness
         return thickness.set(device, object, type, mem);
      case 10: //attenuationDistance
         return attenuationDistance.set(device, object, type, mem);
      case 9: //attenuationColor
         return attenuationColor.set(device, object, type, mem);
      case 80: //sheenColor
         return sheenColor.set(device, object, type, mem);
      case 81: //sheenRoughness
         return sheenRoughness.set(device, object, type, mem);
      case 47: //iridescence
         return iridescence.set(device, object, type, mem);
      case 48: //iridescenceIor
         return iridescenceIor.set(device, object, type, mem);
      case 49: //iridescenceThickness
         return iridescenceThickness.set(device, object, type, mem);
      default: // unknown param
         //unknown parameter
         return false;
   }
}
void MaterialPhysicallyBased::unset(const char *paramname) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: //name
         name.unset(device, object);
         return;
      case 12: //baseColor
         {
            float value[] = {1.000000f, 1.000000f, 1.000000f};
            baseColor.set(device, object, ANARI_FLOAT32_VEC3, value);
         }
         return;
      case 60: //opacity
         {
            float value[] = {1.000000f};
            opacity.set(device, object, ANARI_FLOAT32, value);
         }
         return;
      case 54: //metallic
         {
            float value[] = {1.000000f};
            metallic.set(device, object, ANARI_FLOAT32, value);
         }
         return;
      case 78: //roughness
         {
            float value[] = {1.000000f};
            roughness.set(device, object, ANARI_FLOAT32, value);
         }
         return;
      case 57: //normal
         normal.unset(device, object);
         return;
      case 25: //emissive
         {
            float value[] = {0.000000f, 0.000000f, 0.000000f};
            emissive.set(device, object, ANARI_FLOAT32_VEC3, value);
         }
         return;
      case 58: //occlusion
         occlusion.unset(device, object);
         return;
      case 3: //alphaMode
         {
            const char *value = "opaque";
            alphaMode.set(device, object, ANARI_STRING, value);
         }
         return;
      case 2: //alphaCutoff
         {
            float value[] = {0.500000f};
            alphaCutoff.set(device, object, ANARI_FLOAT32, value);
         }
         return;
      case 84: //specular
         {
            float value[] = {0.000000f};
            specular.set(device, object, ANARI_FLOAT32, value);
         }
         return;
      case 85: //specularColor
         {
            float value[] = {1.000000f, 1.000000f, 1.000000f};
            specularColor.set(device, object, ANARI_FLOAT32_VEC3, value);
         }
         return;
      case 17: //clearcoat
         {
            float value[] = {0.000000f};
            clearcoat.set(device, object, ANARI_FLOAT32, value);
         }
         return;
      case 19: //clearcoatRoughness
         {
            float value[] = {0.000000f};
            clearcoatRoughness.set(device, object, ANARI_FLOAT32, value);
         }
         return;
      case 18: //clearcoatNormal
         clearcoatNormal.unset(device, object);
         return;
      case 92: //transmission
         {
            float value[] = {0.000000f};
            transmission.set(device, object, ANARI_FLOAT32, value);
         }
         return;
      case 46: //ior
         {
            float value[] = {1.500000f};
            ior.set(device, object, ANARI_FLOAT32, value);
         }
         return;
      case 90: //thickness
         {
            float value[] = {0.000000f};
            thickness.set(device, object, ANARI_FLOAT32, value);
         }
         return;
      case 10: //attenuationDistance
         {
            const char *value = "INFINITY";
            attenuationDistance.set(device, object, ANARI_FLOAT32, value);
         }
         return;
      case 9: //attenuationColor
         {
            float value[] = {1.000000f, 1.000000f, 1.000000f};
            attenuationColor.set(device, object, ANARI_FLOAT32_VEC3, value);
         }
         return;
      case 80: //sheenColor
         {
            float value[] = {0.000000f, 0.000000f, 0.000000f};
            sheenColor.set(device, object, ANARI_FLOAT32_VEC3, value);
         }
         return;
      case 81: //sheenRoughness
         {
            float value[] = {0.000000f};
            sheenRoughness.set(device, object, ANARI_FLOAT32, value);
         }
         return;
      case 47: //iridescence
         {
            float value[] = {0.000000f};
            iridescence.set(device, object, ANARI_FLOAT32, value);
         }
         return;
      case 48: //iridescenceIor
         {
            float value[] = {1.300000f};
            iridescenceIor.set(device, object, ANARI_FLOAT32, value);
         }
         return;
      case 49: //iridescenceThickness
         {
            float value[] = {0.000000f};
            iridescenceThickness.set(device, object, ANARI_FLOAT32, value);
         }
         return;
      default: // unknown param
         //unknown parameter
         return;
   }
}
ParameterBase& MaterialPhysicallyBased::operator[](size_t idx) {
   static EmptyParameter empty;
   switch(idx) {
      case 0: return name;
      case 1: return baseColor;
      case 2: return opacity;
      case 3: return metallic;
      case 4: return roughness;
      case 5: return normal;
      case 6: return emissive;
      case 7: return occlusion;
      case 8: return alphaMode;
      case 9: return alphaCutoff;
      case 10: return specular;
      case 11: return specularColor;
      case 12: return clearcoat;
      case 13: return clearcoatRoughness;
      case 14: return clearcoatNormal;
      case 15: return transmission;
      case 16: return ior;
      case 17: return thickness;
      case 18: return attenuationDistance;
      case 19: return attenuationColor;
      case 20: return sheenColor;
      case 21: return sheenRoughness;
      case 22: return iridescence;
      case 23: return iridescenceIor;
      case 24: return iridescenceThickness;
      default: return empty;
   }
}
ParameterBase& MaterialPhysicallyBased::operator[](const char *paramname) {
   static EmptyParameter empty;
   int idx = param_hash(paramname);
   switch(idx) {
      case 55: return name;
      case 12: return baseColor;
      case 60: return opacity;
      case 54: return metallic;
      case 78: return roughness;
      case 57: return normal;
      case 25: return emissive;
      case 58: return occlusion;
      case 3: return alphaMode;
      case 2: return alphaCutoff;
      case 84: return specular;
      case 85: return specularColor;
      case 17: return clearcoat;
      case 19: return clearcoatRoughness;
      case 18: return clearcoatNormal;
      case 92: return transmission;
      case 46: return ior;
      case 90: return thickness;
      case 10: return attenuationDistance;
      case 9: return attenuationColor;
      case 80: return sheenColor;
      case 81: return sheenRoughness;
      case 47: return iridescence;
      case 48: return iridescenceIor;
      case 49: return iridescenceThickness;
      default: return empty;
   }
}
const char ** MaterialPhysicallyBased::paramNames() const {
   static const char *paramnames[] = {
      "name",
      "baseColor",
      "opacity",
      "metallic",
      "roughness",
      "normal",
      "emissive",
      "occlusion",
      "alphaMode",
      "alphaCutoff",
      "specular",
      "specularColor",
      "clearcoat",
      "clearcoatRoughness",
      "clearcoatNormal",
      "transmission",
      "ior",
      "thickness",
      "attenuationDistance",
      "attenuationColor",
      "sheenColor",
      "sheenRoughness",
      "iridescence",
      "iridescenceIor",
      "iridescenceThickness",
      nullptr
   };
   return paramnames;
}
size_t MaterialPhysicallyBased::paramCount() const {
   return 25;
}

} //namespace visgl
