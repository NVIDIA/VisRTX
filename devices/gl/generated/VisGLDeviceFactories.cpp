// Copyright (c) 2019-2023 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
// SPDX-License-Identifier: BSD-3-Clause
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
// 1. Redistributions of source code must retain the above copyright notice,
// this list of conditions and the following disclaimer.
//
// 2. Redistributions in binary form must reproduce the above copyright notice,
// this list of conditions and the following disclaimer in the documentation
// and/or other materials provided with the distribution.
//
// 3. Neither the name of the copyright holder nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
// This file was generated by generate_device_frontend.py
// Don't make changes to this directly

#include "VisGLDevice.h"
#include "VisGLObjects.h"
#include "VisGLSpecializations.h"
namespace visgl{
static int obj_hash(const char *str) {
   static const uint32_t table[] = {0x7a6f0012u,0x6a650027u,0x0u,0x0u,0x0u,0x0u,0x6e6d003cu,0x0u,0x0u,0x0u,0x62610049u,0x0u,0x7372004eu,0x7365005au,0x0u,0x0u,0x7570008cu,0x737200afu,0x6f6e001du,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6d6c0020u,0x6665001eu,0x100001fu,0x80000000u,0x6a690021u,0x6f6e0022u,0x65640023u,0x66650024u,0x73720025u,0x1000026u,0x80000001u,0x6766002cu,0x0u,0x0u,0x0u,0x73720032u,0x6261002du,0x7675002eu,0x6d6c002fu,0x75740030u,0x1000031u,0x80000002u,0x66650033u,0x64630034u,0x75740035u,0x6a690036u,0x706f0037u,0x6f6e0038u,0x62610039u,0x6d6c003au,0x100003bu,0x80000003u,0x6261003du,0x6867003eu,0x6665003fu,0x34310040u,0x45440043u,0x45440045u,0x45440047u,0x1000044u,0x80000004u,0x1000046u,0x80000005u,0x1000048u,0x80000006u,0x7574004au,0x7574004bu,0x6665004cu,0x100004du,0x80000007u,0x7574004fu,0x69680050u,0x706f0051u,0x68670052u,0x73720053u,0x62610054u,0x71700055u,0x69680056u,0x6a690057u,0x64630058u,0x1000059u,0x80000008u,0x73720068u,0x0u,0x0u,0x7a790072u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6a690080u,0x0u,0x0u,0x6a690084u,0x74730069u,0x7170006au,0x6665006bu,0x6463006cu,0x7574006du,0x6a69006eu,0x7776006fu,0x66650070u,0x1000071u,0x80000009u,0x74730073u,0x6a690074u,0x64630075u,0x62610076u,0x6d6c0077u,0x6d6c0078u,0x7a790079u,0x4342007au,0x6261007bu,0x7473007cu,0x6665007du,0x6564007eu,0x100007fu,0x8000000au,0x6f6e0081u,0x75740082u,0x1000083u,0x8000000bu,0x6e6d0085u,0x6a690086u,0x75740087u,0x6a690088u,0x77760089u,0x6665008au,0x100008bu,0x8000000cu,0x70680091u,0x0u,0x0u,0x0u,0x7372009fu,0x66650099u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x7574009du,0x7372009au,0x6665009bu,0x100009cu,0x8000000du,0x100009eu,0x8000000eu,0x767500a0u,0x646300a1u,0x757400a2u,0x767500a3u,0x737200a4u,0x666500a5u,0x656400a6u,0x535200a7u,0x666500a8u,0x686700a9u,0x767500aau,0x6d6c00abu,0x626100acu,0x737200adu,0x10000aeu,0x8000000fu,0x6a6100b0u,0x6f6e00b9u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x626100d6u,0x747300bau,0x676600bbu,0x706500bcu,0x737200c7u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x737200d3u,0x474600c8u,0x767500c9u,0x6f6e00cau,0x646300cbu,0x757400ccu,0x6a6900cdu,0x706f00ceu,0x6f6e00cfu,0x323100d0u,0x454400d1u,0x10000d2u,0x80000010u,0x6e6d00d4u,0x10000d5u,0x80000011u,0x6f6e00d7u,0x686700d8u,0x6d6c00d9u,0x666500dau,0x10000dbu,0x80000012u};
   uint32_t cur = 0x75630000u;
   for(int i = 0;cur!=0;++i) {
      uint32_t idx = cur&0xFFFFu;
      uint32_t low = (cur>>16u)&0xFFu;
      uint32_t high = (cur>>24u)&0xFFu;
      uint32_t c = (uint32_t)str[i];
      if(c>=low && c<high) {
         cur = table[idx+c-low];
      } else {
         break;
      }
      if(cur&0x80000000u) {
         return cur&0xFFFFu;
      }
      if(str[i]==0) {
         break;
      }
   }
   return -1;
}
ANARIArray1D VisGLDevice::newArray1D(const void* appMemory, ANARIMemoryDeleter deleter, const void* userdata, ANARIDataType type, uint64_t numItems1) {
   return allocate<ANARIArray1D, Array1D>(appMemory, deleter, userdata, type, numItems1);
}
ANARIArray2D VisGLDevice::newArray2D(const void* appMemory, ANARIMemoryDeleter deleter, const void* userdata, ANARIDataType type, uint64_t numItems1, uint64_t numItems2) {
   return allocate<ANARIArray2D, Array2D>(appMemory, deleter, userdata, type, numItems1, numItems2);
}
ANARIArray3D VisGLDevice::newArray3D(const void* appMemory, ANARIMemoryDeleter deleter, const void* userdata, ANARIDataType type, uint64_t numItems1, uint64_t numItems2, uint64_t numItems3) {
   return allocate<ANARIArray3D, Array3D>(appMemory, deleter, userdata, type, numItems1, numItems2, numItems3);
}
ANARIFrame VisGLDevice::newFrame() {
   return allocate<ANARIFrame, Frame>();
}
ANARIGroup VisGLDevice::newGroup() {
   return allocate<ANARIGroup, Group>();
}
ANARIWorld VisGLDevice::newWorld() {
   return allocate<ANARIWorld, World>();
}
ANARIRenderer VisGLDevice::newRenderer(const char *type) {
   int idx = obj_hash(type);
   switch(idx) {
      case 2: //default
         return allocate<ANARIRenderer, RendererDefault>();
      default: // unknown object
         return 0;
   }
   return 0;
}
ANARISurface VisGLDevice::newSurface() {
   return allocate<ANARISurface, Surface>();
}
ANARIInstance VisGLDevice::newInstance(const char *type) {
   int idx = obj_hash(type);
   switch(idx) {
      case 17: //transform
         return allocate<ANARIInstance, InstanceTransform>();
      default: // unknown object
         return 0;
   }
   return 0;
}
ANARIVolume VisGLDevice::newVolume(const char *type) {
   int idx = obj_hash(type);
   switch(idx) {
      case 16: //transferFunction1D
         return allocate<ANARIVolume, VolumeTransferFunction1D>();
      default: // unknown object
         return 0;
   }
   return 0;
}
ANARICamera VisGLDevice::newCamera(const char *type) {
   int idx = obj_hash(type);
   switch(idx) {
      case 8: //orthographic
         return allocate<ANARICamera, CameraOrthographic>();
      case 9: //perspective
         return allocate<ANARICamera, CameraPerspective>();
      default: // unknown object
         return 0;
   }
   return 0;
}
ANARIGeometry VisGLDevice::newGeometry(const char *type) {
   int idx = obj_hash(type);
   switch(idx) {
      case 1: //cylinder
         return allocate<ANARIGeometry, GeometryCylinder>();
      case 13: //sphere
         return allocate<ANARIGeometry, GeometrySphere>();
      case 18: //triangle
         return allocate<ANARIGeometry, GeometryTriangle>();
      case 0: //cone
         return allocate<ANARIGeometry, GeometryCone>();
      default: // unknown object
         return 0;
   }
   return 0;
}
ANARILight VisGLDevice::newLight(const char *type) {
   int idx = obj_hash(type);
   switch(idx) {
      case 3: //directional
         return allocate<ANARILight, LightDirectional>();
      case 11: //point
         return allocate<ANARILight, LightPoint>();
      case 14: //spot
         return allocate<ANARILight, LightSpot>();
      default: // unknown object
         return 0;
   }
   return 0;
}
ANARIMaterial VisGLDevice::newMaterial(const char *type) {
   int idx = obj_hash(type);
   switch(idx) {
      case 7: //matte
         return allocate<ANARIMaterial, MaterialMatte>();
      case 10: //physicallyBased
         return allocate<ANARIMaterial, MaterialPhysicallyBased>();
      default: // unknown object
         return 0;
   }
   return 0;
}
ANARISampler VisGLDevice::newSampler(const char *type) {
   int idx = obj_hash(type);
   switch(idx) {
      case 4: //image1D
         return allocate<ANARISampler, SamplerImage1D>();
      case 5: //image2D
         return allocate<ANARISampler, SamplerImage2D>();
      case 6: //image3D
         return allocate<ANARISampler, SamplerImage3D>();
      case 12: //primitive
         return allocate<ANARISampler, SamplerPrimitive>();
      case 17: //transform
         return allocate<ANARISampler, SamplerTransform>();
      default: // unknown object
         return 0;
   }
   return 0;
}
ANARISpatialField VisGLDevice::newSpatialField(const char *type) {
   int idx = obj_hash(type);
   switch(idx) {
      case 15: //structuredRegular
         return allocate<ANARISpatialField, Spatial_FieldStructuredRegular>();
      default: // unknown object
         return 0;
   }
   return 0;
}
} //namespace visgl
