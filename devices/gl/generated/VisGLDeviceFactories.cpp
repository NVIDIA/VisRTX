// Copyright (c) 2019-2024 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
// SPDX-License-Identifier: BSD-3-Clause
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
// 1. Redistributions of source code must retain the above copyright notice,
// this list of conditions and the following disclaimer.
//
// 2. Redistributions in binary form must reproduce the above copyright notice,
// this list of conditions and the following disclaimer in the documentation
// and/or other materials provided with the distribution.
//
// 3. Neither the name of the copyright holder nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
// This file was generated by generate_device_frontend.py
// Don't make changes to this directly

#include "VisGLDevice.h"
#include "VisGLObjects.h"
#include "VisGLSpecializations.h"
namespace visgl{
static int obj_hash(const char *str) {
   static const uint32_t table[] = {0x7a6f0012u,0x6a650037u,0x0u,0x0u,0x0u,0x0u,0x6e6d004cu,0x0u,0x0u,0x0u,0x62610059u,0x0u,0x7372005eu,0x7365006au,0x0u,0x0u,0x7570009cu,0x737200bfu,0x6f6d001du,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6d6c0030u,0x7170001fu,0x6665002eu,0x73720020u,0x66650021u,0x74730022u,0x74730023u,0x66650024u,0x65640025u,0x4a490026u,0x6e6d0027u,0x62610028u,0x68670029u,0x6665002au,0x3332002bu,0x4544002cu,0x100002du,0x80000000u,0x100002fu,0x80000001u,0x6a690031u,0x6f6e0032u,0x65640033u,0x66650034u,0x73720035u,0x1000036u,0x80000002u,0x6766003cu,0x0u,0x0u,0x0u,0x73720042u,0x6261003du,0x7675003eu,0x6d6c003fu,0x75740040u,0x1000041u,0x80000003u,0x66650043u,0x64630044u,0x75740045u,0x6a690046u,0x706f0047u,0x6f6e0048u,0x62610049u,0x6d6c004au,0x100004bu,0x80000004u,0x6261004du,0x6867004eu,0x6665004fu,0x34310050u,0x45440053u,0x45440055u,0x45440057u,0x1000054u,0x80000005u,0x1000056u,0x80000006u,0x1000058u,0x80000007u,0x7574005au,0x7574005bu,0x6665005cu,0x100005du,0x80000008u,0x7574005fu,0x69680060u,0x706f0061u,0x68670062u,0x73720063u,0x62610064u,0x71700065u,0x69680066u,0x6a690067u,0x64630068u,0x1000069u,0x80000009u,0x73720078u,0x0u,0x0u,0x7a790082u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6a690090u,0x0u,0x0u,0x6a690094u,0x74730079u,0x7170007au,0x6665007bu,0x6463007cu,0x7574007du,0x6a69007eu,0x7776007fu,0x66650080u,0x1000081u,0x8000000au,0x74730083u,0x6a690084u,0x64630085u,0x62610086u,0x6d6c0087u,0x6d6c0088u,0x7a790089u,0x4342008au,0x6261008bu,0x7473008cu,0x6665008du,0x6564008eu,0x100008fu,0x8000000bu,0x6f6e0091u,0x75740092u,0x1000093u,0x8000000cu,0x6e6d0095u,0x6a690096u,0x75740097u,0x6a690098u,0x77760099u,0x6665009au,0x100009bu,0x8000000du,0x706800a1u,0x0u,0x0u,0x0u,0x737200afu,0x666500a9u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x757400adu,0x737200aau,0x666500abu,0x10000acu,0x8000000eu,0x10000aeu,0x8000000fu,0x767500b0u,0x646300b1u,0x757400b2u,0x767500b3u,0x737200b4u,0x666500b5u,0x656400b6u,0x535200b7u,0x666500b8u,0x686700b9u,0x767500bau,0x6d6c00bbu,0x626100bcu,0x737200bdu,0x10000beu,0x80000010u,0x6a6100c0u,0x6f6e00c9u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x626100e6u,0x747300cau,0x676600cbu,0x706500ccu,0x737200d7u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x737200e3u,0x474600d8u,0x767500d9u,0x6f6e00dau,0x646300dbu,0x757400dcu,0x6a6900ddu,0x706f00deu,0x6f6e00dfu,0x323100e0u,0x454400e1u,0x10000e2u,0x80000011u,0x6e6d00e4u,0x10000e5u,0x80000012u,0x6f6e00e7u,0x686700e8u,0x6d6c00e9u,0x666500eau,0x10000ebu,0x80000013u};
   uint32_t cur = 0x75630000u;
   for(int i = 0;cur!=0;++i) {
      uint32_t idx = cur&0xFFFFu;
      uint32_t low = (cur>>16u)&0xFFu;
      uint32_t high = (cur>>24u)&0xFFu;
      uint32_t c = (uint32_t)str[i];
      if(c>=low && c<high) {
         cur = table[idx+c-low];
      } else {
         break;
      }
      if(cur&0x80000000u) {
         return cur&0xFFFFu;
      }
      if(str[i]==0) {
         break;
      }
   }
   return -1;
}
ANARIArray1D VisGLDevice::newArray1D(const void* appMemory, ANARIMemoryDeleter deleter, const void* userdata, ANARIDataType type, uint64_t numItems1) {
   return allocate<ANARIArray1D, Array1D>(appMemory, deleter, userdata, type, numItems1);
}
ANARIArray2D VisGLDevice::newArray2D(const void* appMemory, ANARIMemoryDeleter deleter, const void* userdata, ANARIDataType type, uint64_t numItems1, uint64_t numItems2) {
   return allocate<ANARIArray2D, Array2D>(appMemory, deleter, userdata, type, numItems1, numItems2);
}
ANARIArray3D VisGLDevice::newArray3D(const void* appMemory, ANARIMemoryDeleter deleter, const void* userdata, ANARIDataType type, uint64_t numItems1, uint64_t numItems2, uint64_t numItems3) {
   return allocate<ANARIArray3D, Array3D>(appMemory, deleter, userdata, type, numItems1, numItems2, numItems3);
}
ANARIFrame VisGLDevice::newFrame() {
   return allocate<ANARIFrame, Frame>();
}
ANARIGroup VisGLDevice::newGroup() {
   return allocate<ANARIGroup, Group>();
}
ANARIWorld VisGLDevice::newWorld() {
   return allocate<ANARIWorld, World>();
}
ANARIRenderer VisGLDevice::newRenderer(const char *type) {
   int idx = obj_hash(type);
   switch(idx) {
      case 3: //default
         return allocate<ANARIRenderer, RendererDefault>();
      default: // unknown object
         return 0;
   }
   return 0;
}
ANARISurface VisGLDevice::newSurface() {
   return allocate<ANARISurface, Surface>();
}
ANARIInstance VisGLDevice::newInstance(const char *type) {
   int idx = obj_hash(type);
   switch(idx) {
      case 18: //transform
         return allocate<ANARIInstance, InstanceTransform>();
      default: // unknown object
         return 0;
   }
   return 0;
}
ANARIVolume VisGLDevice::newVolume(const char *type) {
   int idx = obj_hash(type);
   switch(idx) {
      case 17: //transferFunction1D
         return allocate<ANARIVolume, VolumeTransferFunction1D>();
      default: // unknown object
         return 0;
   }
   return 0;
}
ANARICamera VisGLDevice::newCamera(const char *type) {
   int idx = obj_hash(type);
   switch(idx) {
      case 9: //orthographic
         return allocate<ANARICamera, CameraOrthographic>();
      case 10: //perspective
         return allocate<ANARICamera, CameraPerspective>();
      default: // unknown object
         return 0;
   }
   return 0;
}
ANARIGeometry VisGLDevice::newGeometry(const char *type) {
   int idx = obj_hash(type);
   switch(idx) {
      case 2: //cylinder
         return allocate<ANARIGeometry, GeometryCylinder>();
      case 14: //sphere
         return allocate<ANARIGeometry, GeometrySphere>();
      case 19: //triangle
         return allocate<ANARIGeometry, GeometryTriangle>();
      case 1: //cone
         return allocate<ANARIGeometry, GeometryCone>();
      default: // unknown object
         return 0;
   }
   return 0;
}
ANARILight VisGLDevice::newLight(const char *type) {
   int idx = obj_hash(type);
   switch(idx) {
      case 4: //directional
         return allocate<ANARILight, LightDirectional>();
      case 12: //point
         return allocate<ANARILight, LightPoint>();
      case 15: //spot
         return allocate<ANARILight, LightSpot>();
      default: // unknown object
         return 0;
   }
   return 0;
}
ANARIMaterial VisGLDevice::newMaterial(const char *type) {
   int idx = obj_hash(type);
   switch(idx) {
      case 8: //matte
         return allocate<ANARIMaterial, MaterialMatte>();
      case 11: //physicallyBased
         return allocate<ANARIMaterial, MaterialPhysicallyBased>();
      default: // unknown object
         return 0;
   }
   return 0;
}
ANARISampler VisGLDevice::newSampler(const char *type) {
   int idx = obj_hash(type);
   switch(idx) {
      case 5: //image1D
         return allocate<ANARISampler, SamplerImage1D>();
      case 6: //image2D
         return allocate<ANARISampler, SamplerImage2D>();
      case 7: //image3D
         return allocate<ANARISampler, SamplerImage3D>();
      case 13: //primitive
         return allocate<ANARISampler, SamplerPrimitive>();
      case 18: //transform
         return allocate<ANARISampler, SamplerTransform>();
      case 0: //compressedImage2D
         return allocate<ANARISampler, SamplerCompressedImage2D>();
      default: // unknown object
         return 0;
   }
   return 0;
}
ANARISpatialField VisGLDevice::newSpatialField(const char *type) {
   int idx = obj_hash(type);
   switch(idx) {
      case 16: //structuredRegular
         return allocate<ANARISpatialField, Spatial_FieldStructuredRegular>();
      default: // unknown object
         return 0;
   }
   return 0;
}
} //namespace visgl
